import {
  NEXT_WINDOW_HISTORY_SUPPORT_VERSION,
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-FU4AFZWL.mjs";

// src/react/router/next.ts
import { usePathname, useRouter, useSearchParams } from "next/navigation";
var useNextRouter = () => {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = typeof window === "undefined" ? new URLSearchParams() : useSearchParams();
  const canUseWindowHistoryAPIs = typeof window !== "undefined" && window.next && window.next.version >= NEXT_WINDOW_HISTORY_SUPPORT_VERSION;
  return {
    mode: "path",
    name: "NextRouter",
    push: (path) => router.push(path),
    replace: (path) => canUseWindowHistoryAPIs ? window.history.replaceState(null, "", path) : router.replace(path),
    shallowPush(path) {
      canUseWindowHistoryAPIs ? window.history.pushState(null, "", path) : router.push(path, {});
    },
    pathname: () => pathname,
    searchParams: () => searchParams
  };
};

// src/react/router/react.tsx
import { createContext, useContext } from "react";

// src/react/router/router.ts
import { withLeadingSlash, withoutTrailingSlash } from "@clerk/shared/url";
var PRESERVED_QUERYSTRING_PARAMS = ["after_sign_in_url", "after_sign_up_url", "redirect_url"];
function normalizePath(path) {
  return withoutTrailingSlash(withLeadingSlash(path));
}
function createClerkRouter(router, basePath = "/") {
  const normalizedBasePath = normalizePath(basePath);
  function makeDestinationUrlWithPreservedQueryParameters(path) {
    const destinationUrl = new URL(path, window.location.origin);
    const currentSearchParams = router.searchParams();
    PRESERVED_QUERYSTRING_PARAMS.forEach((key) => {
      const maybeValue = currentSearchParams.get(key);
      if (maybeValue) {
        destinationUrl.searchParams.set(key, maybeValue);
      }
    });
    return `${destinationUrl.pathname}${destinationUrl.search}`;
  }
  function match(path, index) {
    const pathToMatch = path != null ? path : index && "/";
    if (!pathToMatch) {
      throw new Error("[clerk] router.match() requires either a path to match, or the index flag must be set to true.");
    }
    const normalizedPath = normalizePath(pathToMatch);
    return normalizePath(`${normalizedBasePath}${normalizedPath}`) === normalizePath(router.pathname());
  }
  function child(childBasePath) {
    return createClerkRouter(router, `${normalizedBasePath}${normalizePath(childBasePath)}`);
  }
  function push(path) {
    const destinationUrl = makeDestinationUrlWithPreservedQueryParameters(path);
    return router.push(destinationUrl);
  }
  function replace(path) {
    const destinationUrl = makeDestinationUrlWithPreservedQueryParameters(path);
    return router.replace(destinationUrl);
  }
  function shallowPush(path) {
    const destinationUrl = makeDestinationUrlWithPreservedQueryParameters(path);
    return router.shallowPush(destinationUrl);
  }
  return {
    child,
    match,
    mode: router.mode,
    name: router.name,
    push,
    replace,
    shallowPush,
    pathname: router.pathname,
    searchParams: router.searchParams,
    basePath: normalizedBasePath
  };
}

// src/react/router/react.tsx
import { jsx } from "react/jsx-runtime";
var ClerkRouterContext = createContext(null);
function useClerkRouter() {
  const ctx = useContext(ClerkRouterContext);
  if (!ctx) {
    throw new Error("clerk: Unable to locate ClerkRouter, make sure this is rendered within `<Router>`.");
  }
  return ctx;
}
function Router({
  basePath,
  children,
  router
}) {
  const clerkRouter = createClerkRouter(router, basePath);
  return /* @__PURE__ */ jsx(ClerkRouterContext.Provider, { value: clerkRouter, children });
}

// src/react/router/virtual.ts
import { useSyncExternalStore } from "react";
var DUMMY_ORIGIN = "https://clerk.dummy";
var _url, _listeners;
var VirtualRouter = class {
  constructor(path) {
    this.name = "VirtualRouter";
    this.mode = "virtual";
    __privateAdd(this, _url);
    __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
    const origin = typeof window === "undefined" ? DUMMY_ORIGIN : window.location.origin;
    __privateSet(this, _url, new URL(path != null ? path : "/", origin));
  }
  push(path) {
    const newUrl = new URL(__privateGet(this, _url).toString());
    newUrl.pathname = path;
    __privateSet(this, _url, newUrl);
    this.emit();
  }
  replace(path) {
    this.push(path);
  }
  shallowPush(path) {
    this.push(path);
  }
  pathname() {
    return __privateGet(this, _url).pathname;
  }
  searchParams() {
    return __privateGet(this, _url).searchParams;
  }
  subscribe(listener) {
    __privateGet(this, _listeners).add(listener);
    return () => __privateGet(this, _listeners).delete(listener);
  }
  emit() {
    __privateGet(this, _listeners).forEach((listener) => listener(__privateGet(this, _url)));
  }
  getSnapshot() {
    return __privateGet(this, _url);
  }
};
_url = new WeakMap();
_listeners = new WeakMap();
var virtualRouter = new VirtualRouter("/");
var useVirtualRouter = () => {
  const url = useSyncExternalStore(
    virtualRouter.subscribe.bind(virtualRouter),
    virtualRouter.getSnapshot.bind(virtualRouter)
  );
  return {
    mode: virtualRouter.mode,
    name: virtualRouter.name,
    pathname: () => url.pathname,
    push: virtualRouter.push.bind(virtualRouter),
    replace: virtualRouter.replace.bind(virtualRouter),
    searchParams: () => url.searchParams,
    shallowPush: virtualRouter.shallowPush.bind(virtualRouter)
  };
};

// src/react/utils/path-inference/next.tsx
import { useRouter as useRouter2 } from "next/compat/router";
import { useParams, usePathname as usePathname2 } from "next/navigation";
import React from "react";

// src/react/utils/path-inference/utils.ts
function removeOptionalCatchAllSegment(pathname) {
  return pathname.replace(/\/\[\[\.\.\..*/, "");
}

// src/react/utils/path-inference/next.tsx
var usePathnameWithoutCatchAll = () => {
  const pathRef = React.useRef();
  const pagesRouter = useRouter2();
  if (pagesRouter) {
    if (pathRef.current) {
      return pathRef.current;
    } else {
      pathRef.current = removeOptionalCatchAllSegment(pagesRouter.pathname);
      return pathRef.current;
    }
  }
  const pathname = usePathname2() || "";
  const pathParts = pathname.split("/").filter(Boolean);
  const catchAllParams = Object.values(useParams() || {}).filter((v) => Array.isArray(v)).flat(Infinity);
  if (pathRef.current) {
    return pathRef.current;
  } else {
    pathRef.current = `/${pathParts.slice(0, pathParts.length - catchAllParams.length).join("/")}`;
    return pathRef.current;
  }
};

export {
  useNextRouter,
  useClerkRouter,
  Router,
  useVirtualRouter,
  usePathnameWithoutCatchAll
};
//# sourceMappingURL=chunk-UDCFBJQW.mjs.map