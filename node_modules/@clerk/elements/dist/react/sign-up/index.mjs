import {
  Router,
  useClerkRouter,
  useNextRouter,
  usePathnameWithoutCatchAll,
  useVirtualRouter
} from "../../chunk-UDCFBJQW.mjs";
import {
  CAPTCHA_ELEMENT_ID,
  ClerkElementsError,
  ClerkElementsRuntimeError,
  ERROR_CODES,
  Form,
  FormStoreProvider,
  MAGIC_LINK_VERIFY_PATH_ROUTE,
  RESENDABLE_COUNTDOWN_DEFAULT,
  ROUTING,
  SEARCH_PARAMS,
  SIGN_IN_DEFAULT_BASE_PATH,
  SIGN_UP_DEFAULT_BASE_PATH,
  SSO_CALLBACK_PATH_ROUTE,
  SignUpRouterCtx,
  SignUpStartCtx,
  SignUpStep,
  SignUpStrategy,
  SignUpVerificationCtx,
  Submit,
  ThirdPartyMachine,
  ThirdPartyMachineId,
  assertActorEventError,
  inspect,
  sendToLoading,
  shouldUseVirtualRouting,
  useFormStore
} from "../../chunk-FU4AFZWL.mjs";

// src/react/sign-up/index.ts
import "client-only";

// src/react/sign-up/root.tsx
import { ClerkLoaded, ClerkLoading, useClerk } from "@clerk/clerk-react";
import { eventComponentMounted } from "@clerk/shared/telemetry";
import { useSelector } from "@xstate/react";
import { useEffect } from "react";
import { createActor } from "xstate";

// src/internals/machines/sign-up/continue.machine.ts
import { snakeToCamel } from "@clerk/shared/underscore";
import { fromPromise, setup } from "xstate";

// src/internals/machines/sign-up/utils/fields-to-params.ts
var SignUpAdditionalKeys = ["firstName", "lastName", "emailAddress", "username", "password", "phoneNumber"];
var signUpKeys = new Set(SignUpAdditionalKeys);
function isSignUpParam(key) {
  return signUpKeys.has(key);
}
function fieldsToSignUpParams(fields) {
  const params = {};
  fields.forEach(({ value }, key) => {
    if (isSignUpParam(key) && value !== void 0) {
      params[key] = value;
    }
  });
  return params;
}

// src/internals/machines/sign-up/continue.machine.ts
var SignUpContinueMachineId = "SignUpContinue";
var SignUpContinueMachine = setup({
  actors: {
    attempt: fromPromise(
      ({ input: { fields, parent } }) => {
        const params = fieldsToSignUpParams(fields);
        return parent.getSnapshot().context.clerk.client.signUp.update(params);
      }
    )
  },
  actions: {
    setFormErrors: ({ context, event }) => {
      assertActorEventError(event);
      context.formRef.send({
        type: "ERRORS.SET",
        error: event.error
      });
    },
    markFormAsProgressive: ({ context }) => {
      const signUp = context.parent.getSnapshot().context.clerk.client.signUp;
      const missing = signUp.missingFields.map(snakeToCamel);
      const optional = signUp.optionalFields.map(snakeToCamel);
      const required = signUp.requiredFields.map(snakeToCamel);
      const progressiveFieldValues = /* @__PURE__ */ new Map();
      for (const key of required.concat(optional)) {
        if (key in signUp) {
          progressiveFieldValues.set(key, signUp[key]);
        }
      }
      context.formRef.send({
        type: "MARK_AS_PROGRESSIVE",
        missing,
        optional,
        required,
        defaultValues: progressiveFieldValues
      });
    },
    unmarkFormAsProgressive: ({ context }) => context.formRef.send({ type: "UNMARK_AS_PROGRESSIVE" }),
    sendToNext: ({ context, event }) => context.parent.send({ type: "NEXT", resource: event.output }),
    sendToLoading
  },
  types: {}
}).createMachine({
  id: SignUpContinueMachineId,
  context: ({ input }) => ({
    basePath: input.basePath || SIGN_UP_DEFAULT_BASE_PATH,
    formRef: input.formRef,
    parent: input.parent,
    loadingStep: "continue"
  }),
  entry: "markFormAsProgressive",
  onDone: {
    actions: "unmarkFormAsProgressive"
  },
  initial: "Pending",
  states: {
    Pending: {
      tags: ["state:pending"],
      description: "Waiting for user input",
      on: {
        SUBMIT: {
          target: "Attempting",
          reenter: true
        }
      }
    },
    Attempting: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attempt",
        src: "attempt",
        input: ({ context }) => ({
          parent: context.parent,
          fields: context.formRef.getSnapshot().context.fields
        }),
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    }
  }
});

// src/internals/machines/sign-up/router.machine.ts
import { joinURL } from "@clerk/shared/url";
import { and as and2, assign as assign2, enqueueActions as enqueueActions2, log as log2, not as not2, or, raise as raise2, sendTo as sendTo3, setup as setup4 } from "xstate";

// src/internals/machines/sign-up/start.machine.ts
import { fromPromise as fromPromise2, not, sendTo, setup as setup2 } from "xstate";
var SignUpStartMachineId = "SignUpStart";
var SignUpStartMachine = setup2({
  actors: {
    attempt: fromPromise2(
      ({ input: { fields, parent } }) => {
        const params = fieldsToSignUpParams(fields);
        return parent.getSnapshot().context.clerk.client.signUp.create(params);
      }
    ),
    thirdParty: ThirdPartyMachine
  },
  actions: {
    sendToNext: ({ context }) => context.parent.send({ type: "NEXT" }),
    sendToLoading,
    setFormErrors: sendTo(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    )
  },
  guards: {
    isExampleMode: ({ context }) => Boolean(context.parent.getSnapshot().context.exampleMode)
  },
  types: {}
}).createMachine({
  id: SignUpStartMachineId,
  context: ({ input }) => ({
    basePath: input.basePath || SIGN_UP_DEFAULT_BASE_PATH,
    formRef: input.formRef,
    parent: input.parent,
    loadingStep: "start"
  }),
  initial: "Pending",
  states: {
    Pending: {
      tags: ["state:pending"],
      description: "Waiting for user input",
      on: {
        SUBMIT: {
          guard: not("isExampleMode"),
          target: "Attempting",
          reenter: true
        }
      }
    },
    Attempting: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attemptCreate",
        src: "attempt",
        input: ({ context }) => ({
          parent: context.parent,
          fields: context.formRef.getSnapshot().context.fields
        }),
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    }
  }
});

// src/internals/machines/sign-up/verification.machine.ts
import { Poller } from "@clerk/shared/poller";
import { and, assign, enqueueActions, fromCallback, fromPromise as fromPromise3, log, raise, sendParent, sendTo as sendTo2, setup as setup3 } from "xstate";

// src/internals/machines/sign-up/verification.types.ts
var SignUpVerificationDelays = {
  emailLinkTimeout: 3e5,
  // 5 minutes
  resendableTimeout: 1e3
  // 1 second
};

// src/internals/machines/sign-up/verification.machine.ts
var SignUpVerificationMachineId = "SignUpVerification";
var shouldVerify = (field, strategy) => {
  const guards = [
    {
      type: "isFieldUnverified",
      params: {
        field
      }
    }
  ];
  if (strategy) {
    guards.push({
      type: "isStrategyEnabled",
      params: {
        attribute: field,
        strategy
      }
    });
  }
  return and(guards);
};
var SignUpVerificationMachine = setup3({
  actors: {
    prepare: fromPromise3(
      ({ input: { params, parent } }) => parent.getSnapshot().context.clerk.client.signUp.prepareVerification(params)
    ),
    attempt: fromPromise3(
      async ({ input: { params, parent } }) => parent.getSnapshot().context.clerk.client.signUp.attemptVerification(params)
    ),
    attemptEmailLinkVerification: fromCallback(
      ({ receive, sendBack, input: { parent } }) => {
        const { run, stop } = Poller();
        const clerk = parent.getSnapshot().context.clerk;
        void run(
          async () => clerk.client.signUp.reload().then((resource) => {
            const signInStatus = resource.status;
            const verificationStatus = resource.verifications.emailAddress.status;
            if (signInStatus === "complete") {
              return sendBack({ type: `EMAIL_LINK.VERIFIED`, resource });
            }
            switch (verificationStatus) {
              case "verified":
              case "transferable":
              case "expired": {
                sendBack({ type: `EMAIL_LINK.${verificationStatus.toUpperCase()}`, resource });
                break;
              }
              case "failed": {
                sendBack({
                  type: `EMAIL_LINK.FAILED`,
                  error: new ClerkElementsError("email-link-verification-failed", "Email verification failed"),
                  resource
                });
                break;
              }
              case "unverified":
              default:
                return;
            }
            stop();
          }).catch((error) => {
            stop();
            new ClerkElementsRuntimeError(error);
          })
        );
        receive((event) => {
          if (event.type === "STOP") {
            stop();
          }
        });
        return () => stop();
      }
    )
  },
  actions: {
    resendableTick: assign(({ context }) => ({
      resendable: context.resendableAfter === 1,
      resendableAfter: context.resendableAfter > 1 ? context.resendableAfter - 1 : context.resendableAfter
    })),
    resendableReset: assign({
      resendable: false,
      resendableAfter: RESENDABLE_COUNTDOWN_DEFAULT
    }),
    sendToLoading,
    setFormErrors: sendTo2(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    )
  },
  guards: {
    isComplete: ({ context }) => context.resource.status === "complete",
    isFieldUnverified: ({ context, event }, { field }) => {
      let resource = context.resource;
      if ((event == null ? void 0 : event.type) === "NEXT" && event.resource) {
        resource = event.resource;
      }
      return resource.unverifiedFields.includes(field);
    },
    isResendable: ({ context }) => context.resendable || context.resendableAfter === 0,
    isStrategyEnabled: ({ context }, { attribute, strategy }) => {
      var _a;
      return Boolean(
        (_a = context.parent.getSnapshot().context.clerk.__unstable__environment) == null ? void 0 : _a.userSettings.attributes[attribute].verifications.includes(strategy)
      );
    },
    shouldVerifyPhoneCode: shouldVerify("phone_number"),
    shouldVerifyEmailLink: shouldVerify("email_address", "email_link"),
    shouldVerifyEmailCode: shouldVerify("email_address", "email_code")
  },
  delays: SignUpVerificationDelays,
  types: {}
}).createMachine({
  id: SignUpVerificationMachineId,
  initial: "Init",
  context: ({ input }) => ({
    basePath: input.basePath || SIGN_UP_DEFAULT_BASE_PATH,
    loadingStep: "verifications",
    formRef: input.formRef,
    parent: input.parent,
    resendable: false,
    resendableAfter: RESENDABLE_COUNTDOWN_DEFAULT,
    resource: input.parent.getSnapshot().context.clerk.client.signUp
  }),
  on: {
    NEXT: [
      {
        guard: "isComplete",
        actions: sendParent(({ event }) => ({ type: "NEXT", resource: event.resource }))
      },
      {
        description: "Validate via phone number",
        guard: "shouldVerifyPhoneCode",
        target: ".PhoneCode"
      },
      {
        description: "Validate via email link",
        guard: "shouldVerifyEmailLink",
        target: ".EmailLink"
      },
      {
        description: "Verify via email code",
        guard: "shouldVerifyEmailCode",
        target: ".EmailCode"
      },
      {
        actions: sendParent(({ event }) => ({ type: "NEXT", resource: event.resource }))
      }
    ]
  },
  states: {
    Init: {
      always: [
        {
          description: "Validate via phone number",
          guard: "shouldVerifyPhoneCode",
          target: "PhoneCode"
        },
        {
          description: "Validate via email link",
          guard: "shouldVerifyEmailLink",
          target: "EmailLink"
        },
        {
          description: "Verify via email code",
          guard: "shouldVerifyEmailCode",
          target: "EmailCode"
        },
        {
          actions: sendParent(({ context }) => ({ type: "NEXT", resource: context.resource }))
        }
      ]
    },
    EmailLink: {
      tags: ["verification:method:email", "verification:category:link", "verification:email_link"],
      initial: "Preparing",
      on: {
        "EMAIL_LINK.RESTART": {
          target: ".Attempting",
          reenter: true
        },
        "EMAIL_LINK.FAILED": {
          actions: [
            {
              type: "setFormErrors",
              params: ({ event }) => ({ error: event.error })
            },
            assign({ resource: ({ event }) => event.resource })
          ],
          target: ".Pending"
        },
        "EMAIL_LINK.*": {
          actions: enqueueActions(({ enqueue, event }) => {
            if (event.type === "EMAIL_LINK.RESTART") {
              return;
            }
            enqueue.assign({ resource: event.resource });
            enqueue.raise({ type: "NEXT", resource: event.resource });
          })
        }
      },
      states: {
        Preparing: {
          tags: ["state:preparing", "state:loading"],
          invoke: {
            id: "prepareEmailLinkVerification",
            src: "prepare",
            input: ({ context }) => ({
              parent: context.parent,
              params: {
                strategy: "email_link",
                redirectUrl: context.parent.getSnapshot().context.clerk.buildUrlWithAuth(`${context.basePath}${MAGIC_LINK_VERIFY_PATH_ROUTE}`)
              }
            }),
            onDone: {
              target: "Attempting",
              actions: assign({ resource: ({ event }) => event.output })
            },
            onError: {
              actions: "setFormErrors",
              target: "Pending"
            }
          }
        },
        Pending: {
          description: "Placeholder for allowing resending of email link",
          tags: ["state:pending"],
          on: {
            NEXT: "Preparing",
            RETRY: "Preparing"
          }
        },
        Attempting: {
          tags: ["state:attempting"],
          invoke: {
            id: "attemptEmailLinkVerification",
            src: "attemptEmailLinkVerification",
            input: ({ context }) => ({
              parent: context.parent
            })
          },
          after: {
            emailLinkTimeout: {
              description: "Timeout after 5 minutes",
              target: "Pending",
              actions: sendTo2(({ context }) => context.formRef, {
                type: "ERRORS.SET",
                error: new ClerkElementsError("verify-email-link-timeout", "Email link verification timed out")
              })
            }
          },
          initial: "NotResendable",
          states: {
            Resendable: {
              description: "Waiting for user to retry"
            },
            NotResendable: {
              description: "Handle countdowns",
              on: {
                RETRY: {
                  actions: log(({ context }) => `Not retriable; Try again in ${context.resendableAfter}s`)
                }
              },
              after: {
                resendableTimeout: [
                  {
                    description: "Set as retriable if countdown is 0",
                    guard: "isResendable",
                    actions: "resendableTick",
                    target: "Resendable"
                  },
                  {
                    description: "Continue countdown if not retriable",
                    actions: "resendableTick",
                    target: "NotResendable",
                    reenter: true
                  }
                ]
              }
            }
          }
        }
      }
    },
    EmailCode: {
      tags: ["verification:method:email", "verification:category:code", "verification:email_code"],
      initial: "Preparing",
      states: {
        Preparing: {
          tags: ["state:preparing", "state:loading"],
          invoke: {
            id: "prepareEmailAddressCodeVerification",
            src: "prepare",
            input: ({ context }) => ({
              parent: context.parent,
              params: {
                strategy: "email_code"
              }
            }),
            onDone: [
              {
                guard: "shouldVerifyEmailCode",
                target: "Pending"
              },
              {
                actions: [
                  assign({ resource: ({ event }) => event.output }),
                  raise(({ event }) => ({ type: "NEXT", resource: event.output }))
                ]
              }
            ]
          }
        },
        Pending: {
          tags: ["state:pending"],
          on: {
            RETRY: "Preparing",
            SUBMIT: {
              target: "Attempting",
              reenter: true
            }
          },
          initial: "NotResendable",
          states: {
            Resendable: {
              description: "Waiting for user to retry"
            },
            NotResendable: {
              description: "Handle countdowns",
              on: {
                RETRY: {
                  actions: log(({ context }) => `Not retriable; Try again in ${context.resendableAfter}s`)
                }
              },
              after: {
                resendableTimeout: [
                  {
                    description: "Set as retriable if countdown is 0",
                    guard: "isResendable",
                    actions: "resendableTick",
                    target: "Resendable"
                  },
                  {
                    description: "Continue countdown if not retriable",
                    actions: "resendableTick",
                    target: "NotResendable",
                    reenter: true
                  }
                ]
              }
            }
          }
        },
        Attempting: {
          tags: ["state:attempting", "state:loading"],
          entry: "sendToLoading",
          invoke: {
            id: "attemptEmailAddressCodeVerification",
            src: "attempt",
            input: ({ context }) => {
              var _a;
              return {
                parent: context.parent,
                params: {
                  strategy: "email_code",
                  code: ((_a = context.formRef.getSnapshot().context.fields.get("code")) == null ? void 0 : _a.value) || ""
                }
              };
            },
            onDone: {
              actions: [raise(({ event }) => ({ type: "NEXT", resource: event.output })), "sendToLoading"]
            },
            onError: {
              actions: ["setFormErrors", "sendToLoading"],
              target: "Pending"
            }
          }
        }
      }
    },
    PhoneCode: {
      tags: ["verification:method:phone", "verification:category:code", "verification:phone_code"],
      initial: "Preparing",
      states: {
        Preparing: {
          tags: ["state:preparing", "state:loading"],
          invoke: {
            id: "preparePhoneCodeVerification",
            src: "prepare",
            input: ({ context }) => ({
              parent: context.parent,
              params: {
                strategy: "phone_code"
              }
            }),
            onDone: [
              {
                guard: "shouldVerifyPhoneCode",
                target: "Pending",
                actions: assign({ resource: ({ event }) => event.output })
              },
              {
                actions: [
                  assign({ resource: ({ event }) => event.output }),
                  raise(({ event }) => ({ type: "NEXT", resource: event.output }))
                ]
              }
            ],
            onError: {
              actions: "setFormErrors",
              target: "Pending"
            }
          }
        },
        Pending: {
          tags: ["state:pending"],
          on: {
            RETRY: "Preparing",
            SUBMIT: {
              target: "Attempting",
              reenter: true
            }
          },
          initial: "NotResendable",
          states: {
            Resendable: {
              description: "Waiting for user to retry"
            },
            NotResendable: {
              description: "Handle countdowns",
              on: {
                RETRY: {
                  actions: log(({ context }) => `Not retriable; Try again in ${context.resendableAfter}s`)
                }
              },
              after: {
                resendableTimeout: [
                  {
                    description: "Set as retriable if countdown is 0",
                    guard: "isResendable",
                    actions: "resendableTick",
                    target: "Resendable"
                  },
                  {
                    description: "Continue countdown if not retriable",
                    actions: "resendableTick",
                    target: "NotResendable",
                    reenter: true
                  }
                ]
              }
            }
          }
        },
        Attempting: {
          tags: ["state:attempting", "state:loading"],
          entry: "sendToLoading",
          invoke: {
            id: "attemptPhoneNumberVerification",
            src: "attempt",
            input: ({ context }) => {
              var _a;
              return {
                parent: context.parent,
                params: {
                  strategy: "phone_code",
                  code: ((_a = context.formRef.getSnapshot().context.fields.get("code")) == null ? void 0 : _a.value) || ""
                }
              };
            },
            onDone: {
              actions: [raise(({ event }) => ({ type: "NEXT", resource: event.output })), "sendToLoading"]
            },
            onError: {
              actions: ["setFormErrors", "sendToLoading"],
              target: "Pending"
            }
          }
        }
      }
    }
  }
});

// src/internals/machines/sign-up/router.machine.ts
var SignUpRouterMachineId = "SignUpRouter";
var isCurrentPath = (path) => ({ context }, _params) => {
  var _a, _b;
  return (_b = (_a = context.router) == null ? void 0 : _a.match(path)) != null ? _b : false;
};
var needsStatus = (status) => ({ context, event }, _) => {
  var _a, _b, _c, _d;
  return ((_a = event == null ? void 0 : event.resource) == null ? void 0 : _a.status) === status || ((_d = (_c = (_b = context.clerk) == null ? void 0 : _b.client) == null ? void 0 : _c.signUp) == null ? void 0 : _d.status) === status;
};
var SignUpRouterMachine = setup4({
  actors: {
    continueMachine: SignUpContinueMachine,
    startMachine: SignUpStartMachine,
    thirdPartyMachine: ThirdPartyMachine,
    verificationMachine: SignUpVerificationMachine
  },
  actions: {
    clearFormErrors: sendTo3(({ context }) => context.formRef, { type: "ERRORS.CLEAR" }),
    logUnknownError: (snapshot) => console.error("Unknown error:", snapshot),
    navigateInternal: ({ context }, { path, force = false }) => {
      if (!context.router) {
        return;
      }
      if (!force && shouldUseVirtualRouting()) {
        return;
      }
      if (context.exampleMode) {
        return;
      }
      const resolvedPath = joinURL(context.router.basePath, path);
      if (resolvedPath === context.router.pathname()) {
        return;
      }
      context.router.shallowPush(resolvedPath);
    },
    navigateExternal: ({ context }, { path }) => {
      var _a;
      return (_a = context.router) == null ? void 0 : _a.push(path);
    },
    raiseNext: raise2({ type: "NEXT" }),
    setActive: ({ context, event }, params) => {
      if (context.exampleMode) {
        return;
      }
      const session = (params == null ? void 0 : params.sessionId) || (params == null ? void 0 : params.useLastActiveSession) && context.clerk.client.lastActiveSessionId || ((event == null ? void 0 : event.resource) || context.clerk.client.signUp).createdSessionId;
      const beforeEmit = () => {
        var _a;
        return (_a = context.router) == null ? void 0 : _a.push(context.clerk.buildAfterSignUpUrl());
      };
      void context.clerk.setActive({ session, beforeEmit });
    },
    delayedReset: raise2({ type: "RESET" }, { delay: 3e3 }),
    // Reset machine after 3s delay.
    setError: assign2({
      error: (_, { error }) => {
        if (error) {
          return error;
        }
        return new ClerkElementsRuntimeError("Unknown error");
      }
    }),
    setFormOAuthErrors: ({ context }) => {
      const errorOrig = context.clerk.client.signIn.firstFactorVerification.error;
      if (!errorOrig) {
        return;
      }
      let error;
      switch (errorOrig.code) {
        case ERROR_CODES.NOT_ALLOWED_TO_SIGN_UP:
        case ERROR_CODES.OAUTH_ACCESS_DENIED:
        case ERROR_CODES.NOT_ALLOWED_ACCESS:
        case ERROR_CODES.SAML_USER_ATTRIBUTE_MISSING:
        case ERROR_CODES.OAUTH_EMAIL_DOMAIN_RESERVED_BY_SAML:
        case ERROR_CODES.USER_LOCKED:
          error = new ClerkElementsError(errorOrig.code, errorOrig.longMessage);
          break;
        default:
          error = new ClerkElementsError(
            "unable_to_complete",
            "Unable to complete action at this time. If the problem persists please contact support."
          );
      }
      context.formRef.send({
        type: "ERRORS.SET",
        error
      });
    },
    transfer: ({ context }) => {
      var _a;
      return (_a = context.router) == null ? void 0 : _a.push(context.clerk.buildSignInUrl());
    }
  },
  guards: {
    areFieldsMissing: ({ context }) => {
      var _a, _b, _c, _d;
      return ((_d = (_c = (_b = (_a = context.clerk) == null ? void 0 : _a.client) == null ? void 0 : _b.signUp) == null ? void 0 : _c.missingFields) == null ? void 0 : _d.length) > 0;
    },
    areFieldsUnverified: ({ context }) => {
      var _a, _b, _c, _d;
      return ((_d = (_c = (_b = (_a = context.clerk) == null ? void 0 : _a.client) == null ? void 0 : _b.signUp) == null ? void 0 : _c.unverifiedFields) == null ? void 0 : _d.length) > 0;
    },
    hasAuthenticatedViaClerkJS: ({ context }) => Boolean(context.clerk.client.signUp.status === null && context.clerk.client.lastActiveSessionId),
    hasCreatedSession: ({ context }) => {
      var _a;
      return Boolean((_a = context.router) == null ? void 0 : _a.searchParams().get(SEARCH_PARAMS.createdSession));
    },
    hasClerkStatus: ({ context }, params) => {
      var _a;
      const value = (_a = context.router) == null ? void 0 : _a.searchParams().get(SEARCH_PARAMS.status);
      if (!params) {
        return Boolean(value);
      }
      return value === params.status;
    },
    hasClerkTransfer: ({ context }) => {
      var _a;
      return Boolean((_a = context.router) == null ? void 0 : _a.searchParams().get(SEARCH_PARAMS.transfer));
    },
    hasResource: ({ context }) => Boolean(context.clerk.client.signUp),
    isStatusAbandoned: needsStatus("abandoned"),
    isStatusComplete: ({ context, event }) => {
      var _a, _b;
      const resource = event == null ? void 0 : event.resource;
      const signUp = (_b = (_a = context.clerk) == null ? void 0 : _a.client) == null ? void 0 : _b.signUp;
      return (resource == null ? void 0 : resource.status) === "complete" && Boolean(resource == null ? void 0 : resource.createdSessionId) || (signUp == null ? void 0 : signUp.status) === "complete" && Boolean(signUp == null ? void 0 : signUp.createdSessionId);
    },
    isStatusMissingRequirements: needsStatus("missing_requirements"),
    isLoggedIn: or(["isStatusComplete", ({ context }) => Boolean(context.clerk.user)]),
    isExampleMode: ({ context }) => Boolean(context.exampleMode),
    isMissingRequiredFields: and2(["isStatusMissingRequirements", "areFieldsMissing"]),
    isMissingRequiredUnverifiedFields: and2(["isStatusMissingRequirements", "areFieldsUnverified"]),
    needsIdentifier: or(["statusNeedsIdentifier", isCurrentPath("/")]),
    needsContinue: and2(["statusNeedsContinue", isCurrentPath("/continue")]),
    needsVerification: and2(["statusNeedsVerification", isCurrentPath("/verify")]),
    needsCallback: isCurrentPath(SSO_CALLBACK_PATH_ROUTE),
    statusNeedsIdentifier: or([not2("hasResource"), "isStatusAbandoned"]),
    statusNeedsContinue: or(["isMissingRequiredFields"]),
    statusNeedsVerification: or(["isMissingRequiredUnverifiedFields", and2(["areFieldsMissing", "hasClerkStatus"])])
  },
  delays: {
    "TIMEOUT.POLLING": 3e5
    // 5 minutes
  },
  types: {}
}).createMachine({
  id: SignUpRouterMachineId,
  // @ts-expect-error - Set in INIT event
  context: {},
  initial: "Idle",
  on: {
    "AUTHENTICATE.OAUTH": {
      actions: sendTo3(ThirdPartyMachineId, ({ context, event }) => {
        var _a, _b, _c;
        return {
          type: "REDIRECT",
          params: {
            strategy: event.strategy,
            redirectUrl: `${((_a = context.router) == null ? void 0 : _a.mode) === ROUTING.virtual ? (_b = context.clerk.__unstable__environment) == null ? void 0 : _b.displayConfig.signUpUrl : (_c = context.router) == null ? void 0 : _c.basePath}${SSO_CALLBACK_PATH_ROUTE}`,
            redirectUrlComplete: context.clerk.buildAfterSignUpUrl()
          }
        };
      })
    },
    "AUTHENTICATE.SAML": {
      actions: sendTo3(ThirdPartyMachineId, {
        type: "REDIRECT",
        params: { strategy: "saml" }
      })
    },
    "FORM.ATTACH": {
      description: "Attach/re-attach the form to the router.",
      actions: enqueueActions2(({ enqueue, event }) => {
        enqueue.assign({
          formRef: event.formRef
        });
        enqueue.raise({ type: "RESET.STEP" });
      })
    },
    "NAVIGATE.PREVIOUS": ".Hist",
    "NAVIGATE.START": ".Start",
    LOADING: {
      actions: assign2(({ event }) => ({
        loading: {
          isLoading: event.isLoading,
          step: event.step,
          strategy: event.strategy
        }
      }))
    },
    RESET: ".Idle"
  },
  states: {
    Idle: {
      on: {
        INIT: {
          actions: assign2(({ event }) => ({
            clerk: event.clerk,
            router: event.router,
            signInPath: event.signInPath || SIGN_IN_DEFAULT_BASE_PATH,
            loading: {
              isLoading: false
            },
            exampleMode: event.exampleMode || false,
            formRef: event.formRef
          })),
          target: "Init"
        }
      }
    },
    Init: {
      entry: enqueueActions2(({ context, enqueue, self }) => {
        var _a, _b;
        if (!self.getSnapshot().children[ThirdPartyMachineId]) {
          enqueue.spawnChild("thirdPartyMachine", {
            id: ThirdPartyMachineId,
            systemId: ThirdPartyMachineId,
            input: {
              basePath: (_b = (_a = context.router) == null ? void 0 : _a.basePath) != null ? _b : SIGN_UP_DEFAULT_BASE_PATH,
              flow: "signUp",
              formRef: context.formRef,
              parent: self
            }
          });
        }
      }),
      always: [
        {
          guard: and2(["isLoggedIn", not2("isExampleMode")]),
          actions: [
            log2("Already logged in"),
            {
              type: "navigateExternal",
              params: ({ context }) => ({ path: context.clerk.buildAfterSignUpUrl() })
            }
          ]
        },
        {
          guard: "needsCallback",
          target: "Callback"
        },
        {
          guard: "needsVerification",
          actions: { type: "navigateInternal", params: { force: true, path: "/verify" } },
          target: "Verification"
        },
        {
          guard: or(["needsContinue", "hasClerkTransfer"]),
          actions: { type: "navigateInternal", params: { force: true, path: "/continue" } },
          target: "Continue"
        },
        {
          actions: { type: "navigateInternal", params: { force: true, path: "/" } },
          target: "Start"
        }
      ]
    },
    Start: {
      tags: "route:start",
      exit: "clearFormErrors",
      invoke: {
        id: "start",
        src: "startMachine",
        input: ({ context, self }) => {
          var _a;
          return {
            basePath: (_a = context.router) == null ? void 0 : _a.basePath,
            formRef: context.formRef,
            parent: self
          };
        },
        onDone: {
          actions: "raiseNext"
        }
      },
      on: {
        "RESET.STEP": {
          target: "Start",
          reenter: true
        },
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            guard: "statusNeedsVerification",
            target: "Verification",
            actions: { type: "navigateInternal", params: { path: "/verify" } }
          },
          {
            guard: "statusNeedsContinue",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "Continue"
          }
        ]
      }
    },
    Continue: {
      tags: "route:continue",
      invoke: {
        id: "continue",
        src: "continueMachine",
        input: ({ context, self }) => {
          var _a;
          return {
            basePath: (_a = context.router) == null ? void 0 : _a.basePath,
            formRef: context.formRef,
            parent: self
          };
        },
        onDone: {
          actions: "raiseNext"
        }
      },
      on: {
        "RESET.STEP": {
          target: "Continue",
          reenter: true
        },
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            guard: "statusNeedsVerification",
            target: "Verification",
            actions: { type: "navigateInternal", params: { path: "/verify" } }
          }
        ]
      }
    },
    Verification: {
      tags: "route:verification",
      invoke: {
        id: "verification",
        src: "verificationMachine",
        input: ({ context, self }) => {
          var _a;
          return {
            basePath: (_a = context.router) == null ? void 0 : _a.basePath,
            formRef: context.formRef,
            parent: self
          };
        },
        onDone: {
          actions: "raiseNext"
        }
      },
      always: [
        {
          guard: "hasCreatedSession",
          actions: [
            ({ context }) => {
              var _a;
              return {
                type: "setActive",
                params: { sessionId: (_a = context.router) == null ? void 0 : _a.searchParams().get(SEARCH_PARAMS.createdSession) }
              };
            },
            "delayedReset"
          ]
        },
        {
          guard: { type: "hasClerkStatus", params: { status: "verified" } },
          actions: { type: "navigateInternal", params: { force: true, path: "/continue" } }
        },
        {
          guard: { type: "hasClerkStatus", params: { status: "expired" } },
          actions: { type: "navigateInternal", params: { force: true, path: "/" } }
        }
      ],
      on: {
        "RESET.STEP": {
          target: "Verification",
          reenter: true
        },
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            guard: "statusNeedsContinue",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "Continue"
          }
        ]
      }
    },
    Callback: {
      tags: "route:callback",
      entry: sendTo3(ThirdPartyMachineId, { type: "CALLBACK" }),
      on: {
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            description: "Handle a case where the user has already been authenticated via ClerkJS",
            guard: "hasAuthenticatedViaClerkJS",
            actions: [{ type: "setActive", params: { useLastActiveSession: true } }, "delayedReset"]
          },
          {
            guard: "statusNeedsVerification",
            actions: { type: "navigateInternal", params: { path: "/verify" } },
            target: "Verification"
          },
          {
            guard: "statusNeedsContinue",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "Continue"
          },
          {
            actions: { type: "navigateInternal", params: { path: "/" } },
            target: "Start"
          }
        ]
      }
    },
    Error: {
      tags: "route:error",
      on: {
        NEXT: {
          target: "Start",
          actions: "clearFormErrors"
        }
      }
    },
    Hist: {
      type: "history",
      exit: "clearFormErrors"
    }
  }
});

// src/react/sign-up/root.tsx
import { jsx, jsxs } from "react/jsx-runtime";
var actor = createActor(SignUpRouterMachine, { inspect });
actor.start();
function SignUpFlowProvider({ children, exampleMode }) {
  const clerk = useClerk();
  const router = useClerkRouter();
  const formRef = useFormStore();
  const isReady = useSelector(actor, (state) => state.value !== "Idle");
  useEffect(() => {
    if (!clerk || !router) {
      return;
    }
    clerk.addOnLoaded(() => {
      const evt = {
        type: "INIT",
        clerk,
        exampleMode,
        formRef,
        router,
        signInPath: SIGN_IN_DEFAULT_BASE_PATH
      };
      if (actor.getSnapshot().can(evt)) {
        actor.send(evt);
      }
      if (formRef && actor.getSnapshot().can({ type: "RESET.STEP" })) {
        actor.send({
          type: "FORM.ATTACH",
          formRef
        });
      }
    });
  }, [clerk, exampleMode, formRef == null ? void 0 : formRef.id, !!router]);
  return isReady ? /* @__PURE__ */ jsx(SignUpRouterCtx.Provider, { actorRef: actor, children }) : null;
}
function SignUpRoot({
  children,
  exampleMode = false,
  fallback = null,
  path: pathProp,
  routing = ROUTING.path
}) {
  var _a;
  const clerk = useClerk();
  const inferredPath = usePathnameWithoutCatchAll();
  const path = pathProp || inferredPath || SIGN_UP_DEFAULT_BASE_PATH;
  (_a = clerk.telemetry) == null ? void 0 : _a.record(
    eventComponentMounted("Elements_SignUpRoot", {
      exampleMode,
      fallback: Boolean(fallback),
      path,
      routing
    })
  );
  const router = (routing === ROUTING.virtual ? useVirtualRouter : useNextRouter)();
  const isRootPath = path === router.pathname();
  return /* @__PURE__ */ jsx(
    Router,
    {
      basePath: path,
      router,
      children: /* @__PURE__ */ jsx(FormStoreProvider, { children: /* @__PURE__ */ jsxs(SignUpFlowProvider, { exampleMode, children: [
        isRootPath ? /* @__PURE__ */ jsx(ClerkLoading, { children: /* @__PURE__ */ jsx(Form, { children: fallback }) }) : null,
        /* @__PURE__ */ jsx(ClerkLoaded, { children })
      ] }) })
    }
  );
}

// src/react/sign-up/action/action.tsx
import * as React3 from "react";

// src/react/sign-up/action/navigate.tsx
import { Slot } from "@radix-ui/react-slot";
import * as React from "react";
import { jsx as jsx2 } from "react/jsx-runtime";
var SIGN_UP_NAVIGATE_NAME = "SignInNavigate";
var SignUpNavigationEventMap = {
  start: `NAVIGATE.START`,
  previous: `NAVIGATE.PREVIOUS`
};
var SignUpNavigate = React.forwardRef(
  ({ asChild, to, ...rest }, forwardedRef) => {
    const actorRef = SignUpRouterCtx.useActorRef();
    const Comp = asChild ? Slot : "button";
    const defaultProps = asChild ? {} : { type: "button" };
    const sendEvent = React.useCallback(() => {
      const type = SignUpNavigationEventMap[to];
      if (actorRef.getSnapshot().can({ type })) {
        actorRef.send({ type });
      } else {
        console.warn("Invalid navigation event.");
      }
    }, [actorRef, to]);
    return /* @__PURE__ */ jsx2(
      Comp,
      {
        ...defaultProps,
        ...rest,
        onClick: sendEvent,
        ref: forwardedRef
      }
    );
  }
);
SignUpNavigate.displayName = SIGN_UP_NAVIGATE_NAME;

// src/react/sign-up/action/resend.tsx
import { Slot as Slot2 } from "@radix-ui/react-slot";
import { useSelector as useSelector2 } from "@xstate/react";
import * as React2 from "react";
import { jsx as jsx3 } from "react/jsx-runtime";
var SIGN_UP_RESEND_NAME = "SignUpResend";
var SignUpResend = React2.forwardRef(
  ({ asChild, fallback, ...rest }, forwardedRef) => {
    const ref = SignUpVerificationCtx.useActorRef(true);
    if (!ref) {
      throw new Error('The resend action must be used within <SignUp.Step name="verifications">.');
    }
    const fallbackProps = useSelector2(
      ref,
      (state) => ({
        resendable: state.context.resendable,
        resendableAfter: state.context.resendableAfter
      }),
      (a, b) => a.resendableAfter === b.resendableAfter && a.resendable === b.resendable
    );
    if (fallback && !fallbackProps.resendable) {
      return typeof fallback === "function" ? fallback(fallbackProps) : fallback;
    }
    const Comp = asChild ? Slot2 : "button";
    const defaultProps = asChild ? {} : { type: "button" };
    return /* @__PURE__ */ jsx3(
      Comp,
      {
        ...defaultProps,
        ...rest,
        disabled: !fallbackProps.resendable,
        onClick: () => ref.send({ type: "RETRY" }),
        ref: forwardedRef
      }
    );
  }
);
SignUpResend.displayName = SIGN_UP_RESEND_NAME;

// src/react/sign-up/action/action.tsx
import { jsx as jsx4 } from "react/jsx-runtime";
var SignUpAction = React3.forwardRef((props, forwardedRef) => {
  const { submit, navigate, resend, ...rest } = props;
  let Comp;
  if (submit) {
    Comp = Submit;
  } else if (navigate) {
    Comp = SignUpNavigate;
  } else if (resend) {
    Comp = SignUpResend;
  }
  return Comp ? /* @__PURE__ */ jsx4(
    Comp,
    {
      to: navigate,
      ...rest,
      ref: forwardedRef
    }
  ) : null;
});
SignUpAction.displayName = "SignUpAction";

// src/react/sign-up/captcha.tsx
import { Slot as Slot3 } from "@radix-ui/react-slot";
import * as React4 from "react";
import { jsx as jsx5 } from "react/jsx-runtime";
var SignUpCaptcha = React4.forwardRef(
  ({ asChild, children, ...rest }, forwardedRef) => {
    const ref = SignUpStartCtx.useActorRef(true);
    if (!ref) {
      throw new ClerkElementsRuntimeError('<Captcha> must be used within the <SignUp.Step name="start"> component.');
    }
    const Comp = asChild ? Slot3 : "div";
    return /* @__PURE__ */ jsx5(
      Comp,
      {
        id: CAPTCHA_ELEMENT_ID,
        ...rest,
        ref: forwardedRef
      }
    );
  }
);
export {
  SignUpAction as Action,
  SignUpCaptcha as Captcha,
  SignUpRoot as Root,
  SignUpRoot as SignUp,
  SignUpStep as Step,
  SignUpStrategy as Strategy
};
//# sourceMappingURL=index.mjs.map