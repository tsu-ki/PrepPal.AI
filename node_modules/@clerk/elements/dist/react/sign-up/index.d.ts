import { R as ROUTING } from '../../index-Bq_JGDwx.js';
export { S as Step, a as Strategy } from '../../step-q70MSctc.js';
import * as React$1 from 'react';
import { j as FormSubmitProps } from '../../index-CbIXjVuO.js';
import 'react/jsx-runtime';
import '@radix-ui/react-form';
import '@clerk/types';
import 'type-fest';
import 'xstate';

type SignUpFlowProviderProps = {
    children: React.ReactNode;
    exampleMode?: boolean;
};
type SignUpRootProps = SignUpFlowProviderProps & {
    /**
     * Fallback markup to render while Clerk is loading
     */
    fallback?: React.ReactNode;
    /**
     * The base path for your sign-up route.
     * Will be automatically inferred in Next.js.
     * @example `/sign-up`
     */
    path?: string;
    /**
     * If you want to render Clerk Elements in e.g. a modal, use the `virtual` routing mode.
     */
    routing?: ROUTING;
};
/**
 * Root component for the sign-up flow. It sets up providers and state management for its children.
 * Must wrap all sign-up related components.
 *
 * @param {string} path - The root path the sign-up flow is mounted at. Will be automatically inferred in Next.js. You can set it to `/sign-up` for example.
 * @param {React.ReactNode} fallback - Fallback markup to render while Clerk is loading. Default: `null`
 * @param {string} routing - If you want to render Clerk Elements in e.g. a modal, use the `'virtual'` routing mode. Default: `'path'`
 *
 * @example
 * import * as SignUp from "@clerk/elements/sign-up"
 *
 * export default SignUpPage = () => (
 *  <SignUp.Root>
 *  </SignUp.Root>
 * )
 */
declare function SignUpRoot({ children, exampleMode, fallback, path: pathProp, routing, }: SignUpRootProps): JSX.Element | null;

declare const SignUpNavigationEventMap: {
    readonly start: "NAVIGATE.START";
    readonly previous: "NAVIGATE.PREVIOUS";
};
type SignUpNavigateElementKey = keyof typeof SignUpNavigationEventMap;
type SignUpNavigateProps = {
    asChild?: boolean;
    to: SignUpNavigateElementKey;
    children: React$1.ReactNode;
};

type SignUpResendFallbackProps = {
    resendable: boolean;
    resendableAfter: number;
};
type SignUpResendProps = {
    asChild?: boolean;
    children: React$1.ReactNode;
    /**
     * A fallback component to render when the resend action is not available.
     * This can be a React element or a function that receives the `resendableAfter` prop.
     */
    fallback?: React$1.ReactNode | ((props: SignUpResendFallbackProps) => React$1.ReactNode);
};

type SignUpActionProps = {
    asChild?: boolean;
} & FormSubmitProps & (({
    navigate: SignUpNavigateProps['to'];
    resend?: never;
    submit?: never;
} & Omit<SignUpNavigateProps, 'to'>) | {
    navigate?: never;
    resend?: never;
    submit: true;
} | ({
    navigate?: never;
    resend: true;
    submit?: never;
} & SignUpResendProps));
/**
 * Perform various actions during the sign-in process. This component is used to navigate between steps, submit the form, or resend a verification codes.
 *
 * @param {boolean} [submit] - If `true`, the action will submit the form.
 * @param {string} [navigate] - The name of the step to navigate to.
 * @param {boolean} [resend] - If `true`, the action will resend the verification code for the currently active strategy, if applicable.
 * @param {Function} [fallback] - Only used when `resend` is `true`. If provided, the fallback markup will be rendered before the resend delay has expired.
 *
 * @example
 * <SignUp.Action navigate="start">Go Back</SignUp.Action>
 *
 * @example
 * <SignUp.Action submit>Sign Up</SignUp.Action>
 *
 * @example
 * <SignUp.Action resend>Resend</SignUp.Action>
 */
declare const SignUpAction: React$1.ForwardRefExoticComponent<SignUpActionProps & React$1.RefAttributes<HTMLButtonElement>>;

type CaptchaElementProps = Omit<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, 'id' | 'children'>;
/**
 * The `<SignUp.Captcha>` component is used to render the Cloudflare Turnstile widget. It must be used within the `<SignUp.Step name="start">` component.
 *
 * If utilizing the `asChild` prop, the component must be a self-closing element or component. Any children passed to the immediate child component of <SignUp.Captcha> will be ignored.
 *
 * @param {boolean} [asChild] - If true, `<Captcha />` will render as its child element, passing along any necessary props.
 *
 * @example
 * <SignUp.Root>
 *   <SignUp.Step name="start">
 *     <SignUp.Captcha />
 *     <Clerk.Action submit>Sign Up</Clerk.Action>
 *   </SignUp.Step>
 * </SignUp.Root>
 *
 * @example
 * <SignUp.Root>
 *   <SignUp.Step name="start">
 *     <SignUp.Captcha asChild>
 *       <aside/>
 *     </SignUp.Captcha>
 *     <Clerk.Action submit>Sign Up</Clerk.Action>
 *   </SignUp.Step>
 * </SignUp.Root>
 */
declare const SignUpCaptcha: React$1.ForwardRefExoticComponent<(Omit<{
    asChild: true;
    children: React$1.ReactElement;
} & CaptchaElementProps, "ref"> | Omit<{
    asChild?: false | undefined;
    children?: undefined;
} & CaptchaElementProps, "ref">) & React$1.RefAttributes<HTMLDivElement>>;

export { SignUpAction as Action, SignUpCaptcha as Captcha, SignUpRoot as Root, SignUpRoot as SignUp };
