"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/react/sign-up/index.ts
var sign_up_exports = {};
__export(sign_up_exports, {
  Action: () => SignUpAction,
  Captcha: () => SignUpCaptcha,
  Root: () => SignUpRoot,
  SignUp: () => SignUpRoot,
  Step: () => SignUpStep,
  Strategy: () => SignUpStrategy
});
module.exports = __toCommonJS(sign_up_exports);
var import_client_only2 = require("client-only");

// src/react/sign-up/root.tsx
var import_clerk_react3 = require("@clerk/clerk-react");
var import_telemetry2 = require("@clerk/shared/telemetry");
var import_react7 = require("@xstate/react");
var import_react8 = require("react");
var import_xstate8 = require("xstate");

// src/internals/constants/index.ts
var SSO_CALLBACK_PATH_ROUTE = "/sso-callback";
var MAGIC_LINK_VERIFY_PATH_ROUTE = "/verify";
var _a, _b;
var SIGN_IN_DEFAULT_BASE_PATH = (_b = (_a = process.env.CLERK_SIGN_IN_URL) != null ? _a : process.env.NEXT_PUBLIC_CLERK_SIGN_IN_URL) != null ? _b : "/sign-in";
var _a2, _b2;
var SIGN_UP_DEFAULT_BASE_PATH = (_b2 = (_a2 = process.env.CLERK_SIGN_UP_URL) != null ? _a2 : process.env.NEXT_PUBLIC_CLERK_SIGN_UP_URL) != null ? _b2 : "/sign-up";
var NEXT_WINDOW_HISTORY_SUPPORT_VERSION = "14.1.0";
var SEARCH_PARAMS = {
  createdSession: "__clerk_created_session",
  handshake: "__clerk_handshake",
  help: "__clerk_help",
  invitationToken: "__clerk_invitation_token",
  modalState: "__clerk_modal_state",
  satelliteUrl: "__clerk_satellite_url",
  status: "__clerk_status",
  synced: "__clerk_synced",
  ticket: "__clerk_ticket",
  transfer: "__clerk_transfer"
};
var RESENDABLE_COUNTDOWN_DEFAULT = 60;
var CAPTCHA_ELEMENT_ID = "clerk-captcha";
var ERROR_CODES = {
  FORM_IDENTIFIER_NOT_FOUND: "form_identifier_not_found",
  FORM_PASSWORD_INCORRECT: "form_password_incorrect",
  INVALID_STRATEGY_FOR_USER: "strategy_for_user_invalid",
  NOT_ALLOWED_TO_SIGN_UP: "not_allowed_to_sign_up",
  OAUTH_ACCESS_DENIED: "oauth_access_denied",
  OAUTH_EMAIL_DOMAIN_RESERVED_BY_SAML: "oauth_email_domain_reserved_by_saml",
  NOT_ALLOWED_ACCESS: "not_allowed_access",
  SAML_USER_ATTRIBUTE_MISSING: "saml_user_attribute_missing",
  USER_LOCKED: "user_locked"
};
var ROUTING = {
  path: "path",
  virtual: "virtual"
};

// src/internals/machines/form/form.context.ts
var import_react = require("@xstate/react");

// src/internals/machines/form/form.machine.ts
var import_error = require("@clerk/shared/error");
var import_underscore = require("@clerk/shared/underscore");
var import_xstate = require("xstate");

// src/internals/errors/index.ts
var ClerkElementsErrorBase = class extends Error {
  constructor(code, message) {
    super(message);
    this.code = code;
    this.clerkError = true;
    this.clerkElementsError = true;
    this.name = "ClerkElementsError";
    this.rawMessage = message;
  }
  toString() {
    return `[${this.name}]
Code: ${this.code}
Message: ${this.message}`;
  }
};
var ClerkElementsError = class _ClerkElementsError extends ClerkElementsErrorBase {
  static fromAPIError(error) {
    return new _ClerkElementsError(error.code, error.longMessage || error.message);
  }
  constructor(code, message) {
    super(code, message);
    this.name = "ClerkElementsError";
  }
};
var ClerkElementsRuntimeError = class extends ClerkElementsErrorBase {
  constructor(message) {
    super("elements_runtime_error", message);
    this.name = "ClerkElementsRuntimeError";
  }
};
var ClerkElementsFieldError = class _ClerkElementsFieldError extends ClerkElementsErrorBase {
  constructor(code, message) {
    super(code, message);
    this.matchFn = () => true;
    this.name = "ClerkElementsFieldError";
  }
  static fromAPIError(error) {
    return new _ClerkElementsFieldError(error.code, error.longMessage || error.message);
  }
  get validityState() {
    return this.code;
  }
  get forceMatch() {
    return true;
  }
};

// src/internals/machines/form/form.machine.ts
var FormMachine = (0, import_xstate.setup)({
  actions: {
    setGlobalErrors: (0, import_xstate.assign)({
      errors: (_, params) => [...params.errors]
    }),
    setFieldFeedback: (0, import_xstate.assign)({
      fields: ({ context }, params) => {
        if (!params.name) {
          throw new Error("Field name is required");
        }
        if (context.fields.has(params.name)) {
          context.fields.get(params.name).feedback = params.feedback;
        }
        return context.fields;
      }
    })
  },
  types: {}
}).createMachine({
  id: "Form",
  context: () => ({
    defaultValues: /* @__PURE__ */ new Map(),
    errors: [],
    fields: /* @__PURE__ */ new Map(),
    progressive: false
  }),
  on: {
    "ERRORS.SET": {
      actions: (0, import_xstate.enqueueActions)(({ enqueue, event }) => {
        var _a3, _b3;
        if ((0, import_error.isKnownError)(event.error)) {
          const fields = {};
          const globalErrors = [];
          for (const error of event.error.errors || [event.error]) {
            const name = (0, import_underscore.snakeToCamel)((_a3 = error.meta) == null ? void 0 : _a3.paramName);
            if (!name) {
              globalErrors.push(ClerkElementsError.fromAPIError(error));
              continue;
            } else if (!fields[name]) {
              fields[name] = [];
            }
            (_b3 = fields[name]) == null ? void 0 : _b3.push(ClerkElementsFieldError.fromAPIError(error));
          }
          enqueue({
            type: "setGlobalErrors",
            params: {
              errors: globalErrors
            }
          });
          for (const field in fields) {
            enqueue({
              type: "setFieldFeedback",
              params: {
                name: field,
                feedback: {
                  type: "error",
                  message: fields[field][0]
                }
              }
            });
          }
        }
      })
    },
    "ERRORS.CLEAR": {
      actions: (0, import_xstate.assign)({
        errors: () => []
      })
    },
    "FIELD.ADD": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          event.field.value = event.field.value || context.defaultValues.get(event.field.name) || void 0;
          context.fields.set(event.field.name, event.field);
          return context.fields;
        }
      })
    },
    "FIELD.UPDATE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          if (context.fields.has(event.field.name)) {
            context.fields.get(event.field.name).value = event.field.value;
          }
          return context.fields;
        }
      })
    },
    "FIELD.REMOVE": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          context.fields.delete(event.field.name);
          return context.fields;
        }
      })
    },
    "FIELD.FEEDBACK.SET": {
      actions: [
        {
          type: "setFieldFeedback",
          params: ({ event }) => event.field
        }
      ]
    },
    "FIELD.FEEDBACK.CLEAR": {
      actions: (0, import_xstate.assign)({
        fields: ({ context, event }) => {
          if (!event.field.name) {
            throw new Error("Field name is required");
          }
          if (context.fields.has(event.field.name)) {
            context.fields.get(event.field.name).feedback = void 0;
          }
          return context.fields;
        }
      })
    },
    "FIELD.FEEDBACK.CLEAR.ALL": {
      actions: (0, import_xstate.assign)({
        fields: ({ context }) => {
          context.fields.forEach((field) => {
            field.feedback = void 0;
          });
          return context.fields;
        }
      })
    },
    MARK_AS_PROGRESSIVE: {
      actions: (0, import_xstate.assign)(({ event }) => {
        const missing = new Set(event.missing);
        return {
          defaultValues: event.defaultValues,
          hidden: /* @__PURE__ */ new Set([...event.required.filter((f) => !missing.has(f)), ...event.optional]),
          missing,
          optional: new Set(event.optional),
          progressive: true,
          required: new Set(event.required)
        };
      })
    },
    UNMARK_AS_PROGRESSIVE: {
      actions: (0, import_xstate.assign)({
        defaultValues: /* @__PURE__ */ new Map(),
        hidden: void 0,
        missing: void 0,
        optional: void 0,
        progressive: false,
        required: void 0
      })
    }
  }
});

// src/internals/utils/inspector/index.ts
var inspect;
if (false) {
  inspect = (_a = getBrowserInspector()) != null ? _a : getConsoleInspector();
}

// src/internals/machines/form/form.context.ts
var FormMachineContext = (0, import_react.createActorContext)(FormMachine, { inspect });
var FormStoreProvider = FormMachineContext.Provider;
var useFormStore = FormMachineContext.useActorRef;
var useFormSelector = FormMachineContext.useSelector;
var globalErrorsSelector = (state) => state.context.errors;
var fieldValueSelector = (name) => (state) => {
  var _a3;
  return name ? (_a3 = state.context.fields.get(name)) == null ? void 0 : _a3.value : "";
};
var fieldHasValueSelector = (name) => (state) => Boolean(fieldValueSelector(name)(state));
var fieldFeedbackSelector = (name) => (state) => {
  var _a3;
  return name ? (_a3 = state.context.fields.get(name)) == null ? void 0 : _a3.feedback : void 0;
};

// src/internals/machines/sign-up/continue.machine.ts
var import_underscore2 = require("@clerk/shared/underscore");
var import_xstate2 = require("xstate");

// src/internals/machines/shared/shared.actions.ts
function sendToLoading({ context, event }) {
  let step;
  let strategy;
  if (event.type.startsWith("xstate.done.") || event.type.startsWith("xstate.error.")) {
    return context.parent.send({
      type: "LOADING",
      isLoading: false,
      step: void 0,
      strategy: void 0
    });
  }
  if (context.loadingStep === "strategy") {
    step = void 0;
    if (event.type === "REDIRECT") {
      strategy = event.params.strategy;
    }
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy
    });
  } else if (context.loadingStep === "continue") {
    step = "continue";
    strategy = void 0;
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy
    });
  } else if (context.loadingStep === "reset-password") {
    step = "reset-password";
    strategy = void 0;
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy
    });
  } else {
    step = context.loadingStep;
    strategy = void 0;
    return context.parent.send({
      type: "LOADING",
      isLoading: true,
      step,
      strategy
    });
  }
}

// src/internals/machines/sign-up/utils/fields-to-params.ts
var SignUpAdditionalKeys = ["firstName", "lastName", "emailAddress", "username", "password", "phoneNumber"];
var signUpKeys = new Set(SignUpAdditionalKeys);
function isSignUpParam(key) {
  return signUpKeys.has(key);
}
function fieldsToSignUpParams(fields) {
  const params = {};
  fields.forEach(({ value }, key) => {
    if (isSignUpParam(key) && value !== void 0) {
      params[key] = value;
    }
  });
  return params;
}

// src/internals/machines/utils/assert.ts
function assertActorEventError(event) {
  if ("error" in event === false) {
    throw new Error(`Expected an error event, got "${event.type}"`);
  }
}

// src/internals/machines/sign-up/continue.machine.ts
var SignUpContinueMachineId = "SignUpContinue";
var SignUpContinueMachine = (0, import_xstate2.setup)({
  actors: {
    attempt: (0, import_xstate2.fromPromise)(
      ({ input: { fields, parent } }) => {
        const params = fieldsToSignUpParams(fields);
        return parent.getSnapshot().context.clerk.client.signUp.update(params);
      }
    )
  },
  actions: {
    setFormErrors: ({ context, event }) => {
      assertActorEventError(event);
      context.formRef.send({
        type: "ERRORS.SET",
        error: event.error
      });
    },
    markFormAsProgressive: ({ context }) => {
      const signUp = context.parent.getSnapshot().context.clerk.client.signUp;
      const missing = signUp.missingFields.map(import_underscore2.snakeToCamel);
      const optional = signUp.optionalFields.map(import_underscore2.snakeToCamel);
      const required = signUp.requiredFields.map(import_underscore2.snakeToCamel);
      const progressiveFieldValues = /* @__PURE__ */ new Map();
      for (const key of required.concat(optional)) {
        if (key in signUp) {
          progressiveFieldValues.set(key, signUp[key]);
        }
      }
      context.formRef.send({
        type: "MARK_AS_PROGRESSIVE",
        missing,
        optional,
        required,
        defaultValues: progressiveFieldValues
      });
    },
    unmarkFormAsProgressive: ({ context }) => context.formRef.send({ type: "UNMARK_AS_PROGRESSIVE" }),
    sendToNext: ({ context, event }) => context.parent.send({ type: "NEXT", resource: event.output }),
    sendToLoading
  },
  types: {}
}).createMachine({
  id: SignUpContinueMachineId,
  context: ({ input }) => ({
    basePath: input.basePath || SIGN_UP_DEFAULT_BASE_PATH,
    formRef: input.formRef,
    parent: input.parent,
    loadingStep: "continue"
  }),
  entry: "markFormAsProgressive",
  onDone: {
    actions: "unmarkFormAsProgressive"
  },
  initial: "Pending",
  states: {
    Pending: {
      tags: ["state:pending"],
      description: "Waiting for user input",
      on: {
        SUBMIT: {
          target: "Attempting",
          reenter: true
        }
      }
    },
    Attempting: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attempt",
        src: "attempt",
        input: ({ context }) => ({
          parent: context.parent,
          fields: context.formRef.getSnapshot().context.fields
        }),
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    }
  }
});

// src/internals/machines/sign-up/router.machine.ts
var import_url = require("@clerk/shared/url");
var import_xstate7 = require("xstate");

// src/internals/machines/third-party/third-party.actors.ts
var import_xstate3 = require("xstate");

// src/internals/machines/utils/clerkjs.ts
function isClerkJSEvent(eventObj, event) {
  return Object.values(eventObj).includes(event);
}
var ClerkJSNavigationEvent = {
  complete: "CLERKJS.NAVIGATE.COMPLETE",
  signUp: "CLERKJS.NAVIGATE.SIGN_UP",
  continue: "CLERKJS.NAVIGATE.CONTINUE",
  generic: "CLERKJS.NAVIGATE.GENERIC",
  resetPassword: "CLERKJS.NAVIGATE.RESET_PASSWORD",
  signIn: "CLERKJS.NAVIGATE.SIGN_IN",
  verification: "CLERKJS.NAVIGATE.VERIFICATION"
};
function isClerkJSNavigationEvent(event) {
  return isClerkJSEvent(ClerkJSNavigationEvent, event);
}

// src/internals/machines/third-party/third-party.actors.ts
var redirect = (0, import_xstate3.fromPromise)(
  async ({ input: { flow, params, parent } }) => {
    const clerk = parent.getSnapshot().context.clerk;
    return clerk.client[flow].authenticateWithRedirect({
      redirectUrl: clerk.buildUrlWithAuth(params.redirectUrl || "/"),
      redirectUrlComplete: clerk.buildUrlWithAuth(params.redirectUrlComplete || "/"),
      ...params
    });
  }
);
var handleRedirectCallback = (0, import_xstate3.fromCallback)(
  ({ sendBack, input: parent }) => {
    var _a3;
    const clerk = parent.getSnapshot().context.clerk;
    const displayConfig = (_a3 = clerk.__unstable__environment) == null ? void 0 : _a3.displayConfig;
    const customNavigate = (toEvt) => {
      const to = toEvt.split("/").slice(-1)[0];
      if (isClerkJSNavigationEvent(to)) {
        sendBack({ type: to });
      } else if (to === (displayConfig == null ? void 0 : displayConfig.signInUrl)) {
        sendBack({ type: ClerkJSNavigationEvent.signIn });
      } else if (to === (displayConfig == null ? void 0 : displayConfig.signUpUrl)) {
        sendBack({ type: ClerkJSNavigationEvent.signUp });
      } else {
        sendBack({ type: "FAILURE", error: new ClerkElementsRuntimeError(`Unknown navigation event: ${to}`) });
      }
      return Promise.resolve();
    };
    const loadedClerk = clerk.clerkjs;
    void loadedClerk.handleRedirectCallback(
      {
        signInForceRedirectUrl: ClerkJSNavigationEvent.complete,
        signInFallbackRedirectUrl: ClerkJSNavigationEvent.complete,
        signUpForceRedirectUrl: ClerkJSNavigationEvent.signUp,
        signUpFallbackRedirectUrl: ClerkJSNavigationEvent.signUp,
        continueSignUpUrl: ClerkJSNavigationEvent.continue,
        firstFactorUrl: ClerkJSNavigationEvent.signIn,
        resetPasswordUrl: ClerkJSNavigationEvent.resetPassword,
        secondFactorUrl: ClerkJSNavigationEvent.signIn,
        verifyEmailAddressUrl: ClerkJSNavigationEvent.verification,
        verifyPhoneNumberUrl: ClerkJSNavigationEvent.verification,
        signUpUrl: ClerkJSNavigationEvent.signUp,
        signInUrl: ClerkJSNavigationEvent.signIn
      },
      customNavigate
    );
    return () => void 0;
  }
);

// src/internals/machines/third-party/third-party.machine.ts
var import_xstate4 = require("xstate");
var ThirdPartyMachineId = "ThirdParty";
var ThirdPartyMachine = (0, import_xstate4.setup)({
  actors: {
    handleRedirectCallback,
    redirect
  },
  actions: {
    logError: (0, import_xstate4.log)(({ event }) => `Error: ${event.type}`),
    assignActiveStrategy: (0, import_xstate4.assign)({
      activeStrategy: ({ event }) => {
        (0, import_xstate4.assertEvent)(event, "REDIRECT");
        return event.params.strategy;
      }
    }),
    unassignActiveStrategy: (0, import_xstate4.assign)({
      activeStrategy: null
    }),
    sendToNext: ({ context }) => context.parent.send({ type: "NEXT" }),
    sendToLoading,
    setFormErrors: (0, import_xstate4.sendTo)(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    )
  },
  guards: {
    isExampleMode: ({ context }) => Boolean(context.parent.getSnapshot().context.exampleMode)
  },
  types: {}
}).createMachine({
  id: ThirdPartyMachineId,
  context: ({ input }) => ({
    activeStrategy: null,
    basePath: input.basePath,
    formRef: input.formRef,
    flow: input.flow,
    parent: input.parent,
    loadingStep: "strategy"
  }),
  initial: "Idle",
  states: {
    Idle: {
      description: "Sets third-party providers if not already set, and waits for a redirect or callback event",
      on: {
        CALLBACK: "HandlingCallback",
        REDIRECT: {
          guard: (0, import_xstate4.not)("isExampleMode"),
          target: "Redirecting",
          reenter: true
        }
      }
    },
    Redirecting: {
      description: "Redirects to the third-party provider for authentication",
      tags: ["state:redirect", "state:loading"],
      entry: ["assignActiveStrategy", "sendToLoading"],
      exit: ["unassignActiveStrategy", "sendToLoading"],
      invoke: {
        id: "redirect",
        src: "redirect",
        input: ({ context, event }) => {
          (0, import_xstate4.assertEvent)(event, "REDIRECT");
          return {
            basePath: context.basePath,
            flow: context.flow,
            params: event.params,
            parent: context.parent
          };
        },
        onError: {
          actions: "setFormErrors",
          target: "Idle"
        }
      }
    },
    HandlingCallback: {
      description: "Handles the callback from the third-party provider",
      tags: ["state:callback", "state:loading"],
      invoke: {
        id: "handleRedirectCallback",
        src: "handleRedirectCallback",
        input: ({ context }) => context.parent,
        onError: {
          actions: ["logError", "setFormErrors"],
          target: "Idle"
        }
      },
      on: {
        "CLERKJS.NAVIGATE.*": {
          actions: "sendToNext",
          target: "Idle"
        }
      }
    }
  }
});

// src/internals/machines/utils/next.ts
function shouldUseVirtualRouting() {
  if (typeof window === "undefined") {
    return false;
  }
  if (!window.next) {
    return false;
  }
  return window.next.version < NEXT_WINDOW_HISTORY_SUPPORT_VERSION;
}

// src/internals/machines/sign-up/start.machine.ts
var import_xstate5 = require("xstate");
var SignUpStartMachineId = "SignUpStart";
var SignUpStartMachine = (0, import_xstate5.setup)({
  actors: {
    attempt: (0, import_xstate5.fromPromise)(
      ({ input: { fields, parent } }) => {
        const params = fieldsToSignUpParams(fields);
        return parent.getSnapshot().context.clerk.client.signUp.create(params);
      }
    ),
    thirdParty: ThirdPartyMachine
  },
  actions: {
    sendToNext: ({ context }) => context.parent.send({ type: "NEXT" }),
    sendToLoading,
    setFormErrors: (0, import_xstate5.sendTo)(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    )
  },
  guards: {
    isExampleMode: ({ context }) => Boolean(context.parent.getSnapshot().context.exampleMode)
  },
  types: {}
}).createMachine({
  id: SignUpStartMachineId,
  context: ({ input }) => ({
    basePath: input.basePath || SIGN_UP_DEFAULT_BASE_PATH,
    formRef: input.formRef,
    parent: input.parent,
    loadingStep: "start"
  }),
  initial: "Pending",
  states: {
    Pending: {
      tags: ["state:pending"],
      description: "Waiting for user input",
      on: {
        SUBMIT: {
          guard: (0, import_xstate5.not)("isExampleMode"),
          target: "Attempting",
          reenter: true
        }
      }
    },
    Attempting: {
      tags: ["state:attempting", "state:loading"],
      entry: "sendToLoading",
      invoke: {
        id: "attemptCreate",
        src: "attempt",
        input: ({ context }) => ({
          parent: context.parent,
          fields: context.formRef.getSnapshot().context.fields
        }),
        onDone: {
          actions: ["sendToNext", "sendToLoading"]
        },
        onError: {
          actions: ["setFormErrors", "sendToLoading"],
          target: "Pending"
        }
      }
    }
  }
});

// src/internals/machines/sign-up/verification.machine.ts
var import_poller = require("@clerk/shared/poller");
var import_xstate6 = require("xstate");

// src/internals/machines/sign-up/verification.types.ts
var SignUpVerificationDelays = {
  emailLinkTimeout: 3e5,
  // 5 minutes
  resendableTimeout: 1e3
  // 1 second
};

// src/internals/machines/sign-up/verification.machine.ts
var SignUpVerificationMachineId = "SignUpVerification";
var shouldVerify = (field, strategy) => {
  const guards = [
    {
      type: "isFieldUnverified",
      params: {
        field
      }
    }
  ];
  if (strategy) {
    guards.push({
      type: "isStrategyEnabled",
      params: {
        attribute: field,
        strategy
      }
    });
  }
  return (0, import_xstate6.and)(guards);
};
var SignUpVerificationMachine = (0, import_xstate6.setup)({
  actors: {
    prepare: (0, import_xstate6.fromPromise)(
      ({ input: { params, parent } }) => parent.getSnapshot().context.clerk.client.signUp.prepareVerification(params)
    ),
    attempt: (0, import_xstate6.fromPromise)(
      async ({ input: { params, parent } }) => parent.getSnapshot().context.clerk.client.signUp.attemptVerification(params)
    ),
    attemptEmailLinkVerification: (0, import_xstate6.fromCallback)(
      ({ receive, sendBack, input: { parent } }) => {
        const { run, stop } = (0, import_poller.Poller)();
        const clerk = parent.getSnapshot().context.clerk;
        void run(
          async () => clerk.client.signUp.reload().then((resource) => {
            const signInStatus = resource.status;
            const verificationStatus = resource.verifications.emailAddress.status;
            if (signInStatus === "complete") {
              return sendBack({ type: `EMAIL_LINK.VERIFIED`, resource });
            }
            switch (verificationStatus) {
              case "verified":
              case "transferable":
              case "expired": {
                sendBack({ type: `EMAIL_LINK.${verificationStatus.toUpperCase()}`, resource });
                break;
              }
              case "failed": {
                sendBack({
                  type: `EMAIL_LINK.FAILED`,
                  error: new ClerkElementsError("email-link-verification-failed", "Email verification failed"),
                  resource
                });
                break;
              }
              case "unverified":
              default:
                return;
            }
            stop();
          }).catch((error) => {
            stop();
            new ClerkElementsRuntimeError(error);
          })
        );
        receive((event) => {
          if (event.type === "STOP") {
            stop();
          }
        });
        return () => stop();
      }
    )
  },
  actions: {
    resendableTick: (0, import_xstate6.assign)(({ context }) => ({
      resendable: context.resendableAfter === 1,
      resendableAfter: context.resendableAfter > 1 ? context.resendableAfter - 1 : context.resendableAfter
    })),
    resendableReset: (0, import_xstate6.assign)({
      resendable: false,
      resendableAfter: RESENDABLE_COUNTDOWN_DEFAULT
    }),
    sendToLoading,
    setFormErrors: (0, import_xstate6.sendTo)(
      ({ context }) => context.formRef,
      ({ event }) => {
        assertActorEventError(event);
        return {
          type: "ERRORS.SET",
          error: event.error
        };
      }
    )
  },
  guards: {
    isComplete: ({ context }) => context.resource.status === "complete",
    isFieldUnverified: ({ context, event }, { field }) => {
      let resource = context.resource;
      if ((event == null ? void 0 : event.type) === "NEXT" && event.resource) {
        resource = event.resource;
      }
      return resource.unverifiedFields.includes(field);
    },
    isResendable: ({ context }) => context.resendable || context.resendableAfter === 0,
    isStrategyEnabled: ({ context }, { attribute, strategy }) => {
      var _a3;
      return Boolean(
        (_a3 = context.parent.getSnapshot().context.clerk.__unstable__environment) == null ? void 0 : _a3.userSettings.attributes[attribute].verifications.includes(strategy)
      );
    },
    shouldVerifyPhoneCode: shouldVerify("phone_number"),
    shouldVerifyEmailLink: shouldVerify("email_address", "email_link"),
    shouldVerifyEmailCode: shouldVerify("email_address", "email_code")
  },
  delays: SignUpVerificationDelays,
  types: {}
}).createMachine({
  id: SignUpVerificationMachineId,
  initial: "Init",
  context: ({ input }) => ({
    basePath: input.basePath || SIGN_UP_DEFAULT_BASE_PATH,
    loadingStep: "verifications",
    formRef: input.formRef,
    parent: input.parent,
    resendable: false,
    resendableAfter: RESENDABLE_COUNTDOWN_DEFAULT,
    resource: input.parent.getSnapshot().context.clerk.client.signUp
  }),
  on: {
    NEXT: [
      {
        guard: "isComplete",
        actions: (0, import_xstate6.sendParent)(({ event }) => ({ type: "NEXT", resource: event.resource }))
      },
      {
        description: "Validate via phone number",
        guard: "shouldVerifyPhoneCode",
        target: ".PhoneCode"
      },
      {
        description: "Validate via email link",
        guard: "shouldVerifyEmailLink",
        target: ".EmailLink"
      },
      {
        description: "Verify via email code",
        guard: "shouldVerifyEmailCode",
        target: ".EmailCode"
      },
      {
        actions: (0, import_xstate6.sendParent)(({ event }) => ({ type: "NEXT", resource: event.resource }))
      }
    ]
  },
  states: {
    Init: {
      always: [
        {
          description: "Validate via phone number",
          guard: "shouldVerifyPhoneCode",
          target: "PhoneCode"
        },
        {
          description: "Validate via email link",
          guard: "shouldVerifyEmailLink",
          target: "EmailLink"
        },
        {
          description: "Verify via email code",
          guard: "shouldVerifyEmailCode",
          target: "EmailCode"
        },
        {
          actions: (0, import_xstate6.sendParent)(({ context }) => ({ type: "NEXT", resource: context.resource }))
        }
      ]
    },
    EmailLink: {
      tags: ["verification:method:email", "verification:category:link", "verification:email_link"],
      initial: "Preparing",
      on: {
        "EMAIL_LINK.RESTART": {
          target: ".Attempting",
          reenter: true
        },
        "EMAIL_LINK.FAILED": {
          actions: [
            {
              type: "setFormErrors",
              params: ({ event }) => ({ error: event.error })
            },
            (0, import_xstate6.assign)({ resource: ({ event }) => event.resource })
          ],
          target: ".Pending"
        },
        "EMAIL_LINK.*": {
          actions: (0, import_xstate6.enqueueActions)(({ enqueue, event }) => {
            if (event.type === "EMAIL_LINK.RESTART") {
              return;
            }
            enqueue.assign({ resource: event.resource });
            enqueue.raise({ type: "NEXT", resource: event.resource });
          })
        }
      },
      states: {
        Preparing: {
          tags: ["state:preparing", "state:loading"],
          invoke: {
            id: "prepareEmailLinkVerification",
            src: "prepare",
            input: ({ context }) => ({
              parent: context.parent,
              params: {
                strategy: "email_link",
                redirectUrl: context.parent.getSnapshot().context.clerk.buildUrlWithAuth(`${context.basePath}${MAGIC_LINK_VERIFY_PATH_ROUTE}`)
              }
            }),
            onDone: {
              target: "Attempting",
              actions: (0, import_xstate6.assign)({ resource: ({ event }) => event.output })
            },
            onError: {
              actions: "setFormErrors",
              target: "Pending"
            }
          }
        },
        Pending: {
          description: "Placeholder for allowing resending of email link",
          tags: ["state:pending"],
          on: {
            NEXT: "Preparing",
            RETRY: "Preparing"
          }
        },
        Attempting: {
          tags: ["state:attempting"],
          invoke: {
            id: "attemptEmailLinkVerification",
            src: "attemptEmailLinkVerification",
            input: ({ context }) => ({
              parent: context.parent
            })
          },
          after: {
            emailLinkTimeout: {
              description: "Timeout after 5 minutes",
              target: "Pending",
              actions: (0, import_xstate6.sendTo)(({ context }) => context.formRef, {
                type: "ERRORS.SET",
                error: new ClerkElementsError("verify-email-link-timeout", "Email link verification timed out")
              })
            }
          },
          initial: "NotResendable",
          states: {
            Resendable: {
              description: "Waiting for user to retry"
            },
            NotResendable: {
              description: "Handle countdowns",
              on: {
                RETRY: {
                  actions: (0, import_xstate6.log)(({ context }) => `Not retriable; Try again in ${context.resendableAfter}s`)
                }
              },
              after: {
                resendableTimeout: [
                  {
                    description: "Set as retriable if countdown is 0",
                    guard: "isResendable",
                    actions: "resendableTick",
                    target: "Resendable"
                  },
                  {
                    description: "Continue countdown if not retriable",
                    actions: "resendableTick",
                    target: "NotResendable",
                    reenter: true
                  }
                ]
              }
            }
          }
        }
      }
    },
    EmailCode: {
      tags: ["verification:method:email", "verification:category:code", "verification:email_code"],
      initial: "Preparing",
      states: {
        Preparing: {
          tags: ["state:preparing", "state:loading"],
          invoke: {
            id: "prepareEmailAddressCodeVerification",
            src: "prepare",
            input: ({ context }) => ({
              parent: context.parent,
              params: {
                strategy: "email_code"
              }
            }),
            onDone: [
              {
                guard: "shouldVerifyEmailCode",
                target: "Pending"
              },
              {
                actions: [
                  (0, import_xstate6.assign)({ resource: ({ event }) => event.output }),
                  (0, import_xstate6.raise)(({ event }) => ({ type: "NEXT", resource: event.output }))
                ]
              }
            ]
          }
        },
        Pending: {
          tags: ["state:pending"],
          on: {
            RETRY: "Preparing",
            SUBMIT: {
              target: "Attempting",
              reenter: true
            }
          },
          initial: "NotResendable",
          states: {
            Resendable: {
              description: "Waiting for user to retry"
            },
            NotResendable: {
              description: "Handle countdowns",
              on: {
                RETRY: {
                  actions: (0, import_xstate6.log)(({ context }) => `Not retriable; Try again in ${context.resendableAfter}s`)
                }
              },
              after: {
                resendableTimeout: [
                  {
                    description: "Set as retriable if countdown is 0",
                    guard: "isResendable",
                    actions: "resendableTick",
                    target: "Resendable"
                  },
                  {
                    description: "Continue countdown if not retriable",
                    actions: "resendableTick",
                    target: "NotResendable",
                    reenter: true
                  }
                ]
              }
            }
          }
        },
        Attempting: {
          tags: ["state:attempting", "state:loading"],
          entry: "sendToLoading",
          invoke: {
            id: "attemptEmailAddressCodeVerification",
            src: "attempt",
            input: ({ context }) => {
              var _a3;
              return {
                parent: context.parent,
                params: {
                  strategy: "email_code",
                  code: ((_a3 = context.formRef.getSnapshot().context.fields.get("code")) == null ? void 0 : _a3.value) || ""
                }
              };
            },
            onDone: {
              actions: [(0, import_xstate6.raise)(({ event }) => ({ type: "NEXT", resource: event.output })), "sendToLoading"]
            },
            onError: {
              actions: ["setFormErrors", "sendToLoading"],
              target: "Pending"
            }
          }
        }
      }
    },
    PhoneCode: {
      tags: ["verification:method:phone", "verification:category:code", "verification:phone_code"],
      initial: "Preparing",
      states: {
        Preparing: {
          tags: ["state:preparing", "state:loading"],
          invoke: {
            id: "preparePhoneCodeVerification",
            src: "prepare",
            input: ({ context }) => ({
              parent: context.parent,
              params: {
                strategy: "phone_code"
              }
            }),
            onDone: [
              {
                guard: "shouldVerifyPhoneCode",
                target: "Pending",
                actions: (0, import_xstate6.assign)({ resource: ({ event }) => event.output })
              },
              {
                actions: [
                  (0, import_xstate6.assign)({ resource: ({ event }) => event.output }),
                  (0, import_xstate6.raise)(({ event }) => ({ type: "NEXT", resource: event.output }))
                ]
              }
            ],
            onError: {
              actions: "setFormErrors",
              target: "Pending"
            }
          }
        },
        Pending: {
          tags: ["state:pending"],
          on: {
            RETRY: "Preparing",
            SUBMIT: {
              target: "Attempting",
              reenter: true
            }
          },
          initial: "NotResendable",
          states: {
            Resendable: {
              description: "Waiting for user to retry"
            },
            NotResendable: {
              description: "Handle countdowns",
              on: {
                RETRY: {
                  actions: (0, import_xstate6.log)(({ context }) => `Not retriable; Try again in ${context.resendableAfter}s`)
                }
              },
              after: {
                resendableTimeout: [
                  {
                    description: "Set as retriable if countdown is 0",
                    guard: "isResendable",
                    actions: "resendableTick",
                    target: "Resendable"
                  },
                  {
                    description: "Continue countdown if not retriable",
                    actions: "resendableTick",
                    target: "NotResendable",
                    reenter: true
                  }
                ]
              }
            }
          }
        },
        Attempting: {
          tags: ["state:attempting", "state:loading"],
          entry: "sendToLoading",
          invoke: {
            id: "attemptPhoneNumberVerification",
            src: "attempt",
            input: ({ context }) => {
              var _a3;
              return {
                parent: context.parent,
                params: {
                  strategy: "phone_code",
                  code: ((_a3 = context.formRef.getSnapshot().context.fields.get("code")) == null ? void 0 : _a3.value) || ""
                }
              };
            },
            onDone: {
              actions: [(0, import_xstate6.raise)(({ event }) => ({ type: "NEXT", resource: event.output })), "sendToLoading"]
            },
            onError: {
              actions: ["setFormErrors", "sendToLoading"],
              target: "Pending"
            }
          }
        }
      }
    }
  }
});

// src/internals/machines/sign-up/router.machine.ts
var SignUpRouterMachineId = "SignUpRouter";
var isCurrentPath = (path) => ({ context }, _params) => {
  var _a3, _b3;
  return (_b3 = (_a3 = context.router) == null ? void 0 : _a3.match(path)) != null ? _b3 : false;
};
var needsStatus = (status) => ({ context, event }, _) => {
  var _a3, _b3, _c, _d;
  return ((_a3 = event == null ? void 0 : event.resource) == null ? void 0 : _a3.status) === status || ((_d = (_c = (_b3 = context.clerk) == null ? void 0 : _b3.client) == null ? void 0 : _c.signUp) == null ? void 0 : _d.status) === status;
};
var SignUpRouterMachine = (0, import_xstate7.setup)({
  actors: {
    continueMachine: SignUpContinueMachine,
    startMachine: SignUpStartMachine,
    thirdPartyMachine: ThirdPartyMachine,
    verificationMachine: SignUpVerificationMachine
  },
  actions: {
    clearFormErrors: (0, import_xstate7.sendTo)(({ context }) => context.formRef, { type: "ERRORS.CLEAR" }),
    logUnknownError: (snapshot) => console.error("Unknown error:", snapshot),
    navigateInternal: ({ context }, { path, force = false }) => {
      if (!context.router) {
        return;
      }
      if (!force && shouldUseVirtualRouting()) {
        return;
      }
      if (context.exampleMode) {
        return;
      }
      const resolvedPath = (0, import_url.joinURL)(context.router.basePath, path);
      if (resolvedPath === context.router.pathname()) {
        return;
      }
      context.router.shallowPush(resolvedPath);
    },
    navigateExternal: ({ context }, { path }) => {
      var _a3;
      return (_a3 = context.router) == null ? void 0 : _a3.push(path);
    },
    raiseNext: (0, import_xstate7.raise)({ type: "NEXT" }),
    setActive: ({ context, event }, params) => {
      if (context.exampleMode) {
        return;
      }
      const session = (params == null ? void 0 : params.sessionId) || (params == null ? void 0 : params.useLastActiveSession) && context.clerk.client.lastActiveSessionId || ((event == null ? void 0 : event.resource) || context.clerk.client.signUp).createdSessionId;
      const beforeEmit = () => {
        var _a3;
        return (_a3 = context.router) == null ? void 0 : _a3.push(context.clerk.buildAfterSignUpUrl());
      };
      void context.clerk.setActive({ session, beforeEmit });
    },
    delayedReset: (0, import_xstate7.raise)({ type: "RESET" }, { delay: 3e3 }),
    // Reset machine after 3s delay.
    setError: (0, import_xstate7.assign)({
      error: (_, { error }) => {
        if (error) {
          return error;
        }
        return new ClerkElementsRuntimeError("Unknown error");
      }
    }),
    setFormOAuthErrors: ({ context }) => {
      const errorOrig = context.clerk.client.signIn.firstFactorVerification.error;
      if (!errorOrig) {
        return;
      }
      let error;
      switch (errorOrig.code) {
        case ERROR_CODES.NOT_ALLOWED_TO_SIGN_UP:
        case ERROR_CODES.OAUTH_ACCESS_DENIED:
        case ERROR_CODES.NOT_ALLOWED_ACCESS:
        case ERROR_CODES.SAML_USER_ATTRIBUTE_MISSING:
        case ERROR_CODES.OAUTH_EMAIL_DOMAIN_RESERVED_BY_SAML:
        case ERROR_CODES.USER_LOCKED:
          error = new ClerkElementsError(errorOrig.code, errorOrig.longMessage);
          break;
        default:
          error = new ClerkElementsError(
            "unable_to_complete",
            "Unable to complete action at this time. If the problem persists please contact support."
          );
      }
      context.formRef.send({
        type: "ERRORS.SET",
        error
      });
    },
    transfer: ({ context }) => {
      var _a3;
      return (_a3 = context.router) == null ? void 0 : _a3.push(context.clerk.buildSignInUrl());
    }
  },
  guards: {
    areFieldsMissing: ({ context }) => {
      var _a3, _b3, _c, _d;
      return ((_d = (_c = (_b3 = (_a3 = context.clerk) == null ? void 0 : _a3.client) == null ? void 0 : _b3.signUp) == null ? void 0 : _c.missingFields) == null ? void 0 : _d.length) > 0;
    },
    areFieldsUnverified: ({ context }) => {
      var _a3, _b3, _c, _d;
      return ((_d = (_c = (_b3 = (_a3 = context.clerk) == null ? void 0 : _a3.client) == null ? void 0 : _b3.signUp) == null ? void 0 : _c.unverifiedFields) == null ? void 0 : _d.length) > 0;
    },
    hasAuthenticatedViaClerkJS: ({ context }) => Boolean(context.clerk.client.signUp.status === null && context.clerk.client.lastActiveSessionId),
    hasCreatedSession: ({ context }) => {
      var _a3;
      return Boolean((_a3 = context.router) == null ? void 0 : _a3.searchParams().get(SEARCH_PARAMS.createdSession));
    },
    hasClerkStatus: ({ context }, params) => {
      var _a3;
      const value = (_a3 = context.router) == null ? void 0 : _a3.searchParams().get(SEARCH_PARAMS.status);
      if (!params) {
        return Boolean(value);
      }
      return value === params.status;
    },
    hasClerkTransfer: ({ context }) => {
      var _a3;
      return Boolean((_a3 = context.router) == null ? void 0 : _a3.searchParams().get(SEARCH_PARAMS.transfer));
    },
    hasResource: ({ context }) => Boolean(context.clerk.client.signUp),
    isStatusAbandoned: needsStatus("abandoned"),
    isStatusComplete: ({ context, event }) => {
      var _a3, _b3;
      const resource = event == null ? void 0 : event.resource;
      const signUp = (_b3 = (_a3 = context.clerk) == null ? void 0 : _a3.client) == null ? void 0 : _b3.signUp;
      return (resource == null ? void 0 : resource.status) === "complete" && Boolean(resource == null ? void 0 : resource.createdSessionId) || (signUp == null ? void 0 : signUp.status) === "complete" && Boolean(signUp == null ? void 0 : signUp.createdSessionId);
    },
    isStatusMissingRequirements: needsStatus("missing_requirements"),
    isLoggedIn: (0, import_xstate7.or)(["isStatusComplete", ({ context }) => Boolean(context.clerk.user)]),
    isExampleMode: ({ context }) => Boolean(context.exampleMode),
    isMissingRequiredFields: (0, import_xstate7.and)(["isStatusMissingRequirements", "areFieldsMissing"]),
    isMissingRequiredUnverifiedFields: (0, import_xstate7.and)(["isStatusMissingRequirements", "areFieldsUnverified"]),
    needsIdentifier: (0, import_xstate7.or)(["statusNeedsIdentifier", isCurrentPath("/")]),
    needsContinue: (0, import_xstate7.and)(["statusNeedsContinue", isCurrentPath("/continue")]),
    needsVerification: (0, import_xstate7.and)(["statusNeedsVerification", isCurrentPath("/verify")]),
    needsCallback: isCurrentPath(SSO_CALLBACK_PATH_ROUTE),
    statusNeedsIdentifier: (0, import_xstate7.or)([(0, import_xstate7.not)("hasResource"), "isStatusAbandoned"]),
    statusNeedsContinue: (0, import_xstate7.or)(["isMissingRequiredFields"]),
    statusNeedsVerification: (0, import_xstate7.or)(["isMissingRequiredUnverifiedFields", (0, import_xstate7.and)(["areFieldsMissing", "hasClerkStatus"])])
  },
  delays: {
    "TIMEOUT.POLLING": 3e5
    // 5 minutes
  },
  types: {}
}).createMachine({
  id: SignUpRouterMachineId,
  // @ts-expect-error - Set in INIT event
  context: {},
  initial: "Idle",
  on: {
    "AUTHENTICATE.OAUTH": {
      actions: (0, import_xstate7.sendTo)(ThirdPartyMachineId, ({ context, event }) => {
        var _a3, _b3, _c;
        return {
          type: "REDIRECT",
          params: {
            strategy: event.strategy,
            redirectUrl: `${((_a3 = context.router) == null ? void 0 : _a3.mode) === ROUTING.virtual ? (_b3 = context.clerk.__unstable__environment) == null ? void 0 : _b3.displayConfig.signUpUrl : (_c = context.router) == null ? void 0 : _c.basePath}${SSO_CALLBACK_PATH_ROUTE}`,
            redirectUrlComplete: context.clerk.buildAfterSignUpUrl()
          }
        };
      })
    },
    "AUTHENTICATE.SAML": {
      actions: (0, import_xstate7.sendTo)(ThirdPartyMachineId, {
        type: "REDIRECT",
        params: { strategy: "saml" }
      })
    },
    "FORM.ATTACH": {
      description: "Attach/re-attach the form to the router.",
      actions: (0, import_xstate7.enqueueActions)(({ enqueue, event }) => {
        enqueue.assign({
          formRef: event.formRef
        });
        enqueue.raise({ type: "RESET.STEP" });
      })
    },
    "NAVIGATE.PREVIOUS": ".Hist",
    "NAVIGATE.START": ".Start",
    LOADING: {
      actions: (0, import_xstate7.assign)(({ event }) => ({
        loading: {
          isLoading: event.isLoading,
          step: event.step,
          strategy: event.strategy
        }
      }))
    },
    RESET: ".Idle"
  },
  states: {
    Idle: {
      on: {
        INIT: {
          actions: (0, import_xstate7.assign)(({ event }) => ({
            clerk: event.clerk,
            router: event.router,
            signInPath: event.signInPath || SIGN_IN_DEFAULT_BASE_PATH,
            loading: {
              isLoading: false
            },
            exampleMode: event.exampleMode || false,
            formRef: event.formRef
          })),
          target: "Init"
        }
      }
    },
    Init: {
      entry: (0, import_xstate7.enqueueActions)(({ context, enqueue, self }) => {
        var _a3, _b3;
        if (!self.getSnapshot().children[ThirdPartyMachineId]) {
          enqueue.spawnChild("thirdPartyMachine", {
            id: ThirdPartyMachineId,
            systemId: ThirdPartyMachineId,
            input: {
              basePath: (_b3 = (_a3 = context.router) == null ? void 0 : _a3.basePath) != null ? _b3 : SIGN_UP_DEFAULT_BASE_PATH,
              flow: "signUp",
              formRef: context.formRef,
              parent: self
            }
          });
        }
      }),
      always: [
        {
          guard: (0, import_xstate7.and)(["isLoggedIn", (0, import_xstate7.not)("isExampleMode")]),
          actions: [
            (0, import_xstate7.log)("Already logged in"),
            {
              type: "navigateExternal",
              params: ({ context }) => ({ path: context.clerk.buildAfterSignUpUrl() })
            }
          ]
        },
        {
          guard: "needsCallback",
          target: "Callback"
        },
        {
          guard: "needsVerification",
          actions: { type: "navigateInternal", params: { force: true, path: "/verify" } },
          target: "Verification"
        },
        {
          guard: (0, import_xstate7.or)(["needsContinue", "hasClerkTransfer"]),
          actions: { type: "navigateInternal", params: { force: true, path: "/continue" } },
          target: "Continue"
        },
        {
          actions: { type: "navigateInternal", params: { force: true, path: "/" } },
          target: "Start"
        }
      ]
    },
    Start: {
      tags: "route:start",
      exit: "clearFormErrors",
      invoke: {
        id: "start",
        src: "startMachine",
        input: ({ context, self }) => {
          var _a3;
          return {
            basePath: (_a3 = context.router) == null ? void 0 : _a3.basePath,
            formRef: context.formRef,
            parent: self
          };
        },
        onDone: {
          actions: "raiseNext"
        }
      },
      on: {
        "RESET.STEP": {
          target: "Start",
          reenter: true
        },
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            guard: "statusNeedsVerification",
            target: "Verification",
            actions: { type: "navigateInternal", params: { path: "/verify" } }
          },
          {
            guard: "statusNeedsContinue",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "Continue"
          }
        ]
      }
    },
    Continue: {
      tags: "route:continue",
      invoke: {
        id: "continue",
        src: "continueMachine",
        input: ({ context, self }) => {
          var _a3;
          return {
            basePath: (_a3 = context.router) == null ? void 0 : _a3.basePath,
            formRef: context.formRef,
            parent: self
          };
        },
        onDone: {
          actions: "raiseNext"
        }
      },
      on: {
        "RESET.STEP": {
          target: "Continue",
          reenter: true
        },
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            guard: "statusNeedsVerification",
            target: "Verification",
            actions: { type: "navigateInternal", params: { path: "/verify" } }
          }
        ]
      }
    },
    Verification: {
      tags: "route:verification",
      invoke: {
        id: "verification",
        src: "verificationMachine",
        input: ({ context, self }) => {
          var _a3;
          return {
            basePath: (_a3 = context.router) == null ? void 0 : _a3.basePath,
            formRef: context.formRef,
            parent: self
          };
        },
        onDone: {
          actions: "raiseNext"
        }
      },
      always: [
        {
          guard: "hasCreatedSession",
          actions: [
            ({ context }) => {
              var _a3;
              return {
                type: "setActive",
                params: { sessionId: (_a3 = context.router) == null ? void 0 : _a3.searchParams().get(SEARCH_PARAMS.createdSession) }
              };
            },
            "delayedReset"
          ]
        },
        {
          guard: { type: "hasClerkStatus", params: { status: "verified" } },
          actions: { type: "navigateInternal", params: { force: true, path: "/continue" } }
        },
        {
          guard: { type: "hasClerkStatus", params: { status: "expired" } },
          actions: { type: "navigateInternal", params: { force: true, path: "/" } }
        }
      ],
      on: {
        "RESET.STEP": {
          target: "Verification",
          reenter: true
        },
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            guard: "statusNeedsContinue",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "Continue"
          }
        ]
      }
    },
    Callback: {
      tags: "route:callback",
      entry: (0, import_xstate7.sendTo)(ThirdPartyMachineId, { type: "CALLBACK" }),
      on: {
        NEXT: [
          {
            guard: "isStatusComplete",
            actions: ["setActive", "delayedReset"]
          },
          {
            description: "Handle a case where the user has already been authenticated via ClerkJS",
            guard: "hasAuthenticatedViaClerkJS",
            actions: [{ type: "setActive", params: { useLastActiveSession: true } }, "delayedReset"]
          },
          {
            guard: "statusNeedsVerification",
            actions: { type: "navigateInternal", params: { path: "/verify" } },
            target: "Verification"
          },
          {
            guard: "statusNeedsContinue",
            actions: { type: "navigateInternal", params: { path: "/continue" } },
            target: "Continue"
          },
          {
            actions: { type: "navigateInternal", params: { path: "/" } },
            target: "Start"
          }
        ]
      }
    },
    Error: {
      tags: "route:error",
      on: {
        NEXT: {
          target: "Start",
          actions: "clearFormErrors"
        }
      }
    },
    Hist: {
      type: "history",
      exit: "clearFormErrors"
    }
  }
});

// src/react/router/next.ts
var import_navigation = require("next/navigation");
var useNextRouter = () => {
  const router = (0, import_navigation.useRouter)();
  const pathname = (0, import_navigation.usePathname)();
  const searchParams = typeof window === "undefined" ? new URLSearchParams() : (0, import_navigation.useSearchParams)();
  const canUseWindowHistoryAPIs = typeof window !== "undefined" && window.next && window.next.version >= NEXT_WINDOW_HISTORY_SUPPORT_VERSION;
  return {
    mode: "path",
    name: "NextRouter",
    push: (path) => router.push(path),
    replace: (path) => canUseWindowHistoryAPIs ? window.history.replaceState(null, "", path) : router.replace(path),
    shallowPush(path) {
      canUseWindowHistoryAPIs ? window.history.pushState(null, "", path) : router.push(path, {});
    },
    pathname: () => pathname,
    searchParams: () => searchParams
  };
};

// src/react/router/react.tsx
var import_react2 = require("react");

// src/react/router/router.ts
var import_url2 = require("@clerk/shared/url");
var PRESERVED_QUERYSTRING_PARAMS = ["after_sign_in_url", "after_sign_up_url", "redirect_url"];
function normalizePath(path) {
  return (0, import_url2.withoutTrailingSlash)((0, import_url2.withLeadingSlash)(path));
}
function createClerkRouter(router, basePath = "/") {
  const normalizedBasePath = normalizePath(basePath);
  function makeDestinationUrlWithPreservedQueryParameters(path) {
    const destinationUrl = new URL(path, window.location.origin);
    const currentSearchParams = router.searchParams();
    PRESERVED_QUERYSTRING_PARAMS.forEach((key) => {
      const maybeValue = currentSearchParams.get(key);
      if (maybeValue) {
        destinationUrl.searchParams.set(key, maybeValue);
      }
    });
    return `${destinationUrl.pathname}${destinationUrl.search}`;
  }
  function match(path, index) {
    const pathToMatch = path != null ? path : index && "/";
    if (!pathToMatch) {
      throw new Error("[clerk] router.match() requires either a path to match, or the index flag must be set to true.");
    }
    const normalizedPath = normalizePath(pathToMatch);
    return normalizePath(`${normalizedBasePath}${normalizedPath}`) === normalizePath(router.pathname());
  }
  function child(childBasePath) {
    return createClerkRouter(router, `${normalizedBasePath}${normalizePath(childBasePath)}`);
  }
  function push(path) {
    const destinationUrl = makeDestinationUrlWithPreservedQueryParameters(path);
    return router.push(destinationUrl);
  }
  function replace(path) {
    const destinationUrl = makeDestinationUrlWithPreservedQueryParameters(path);
    return router.replace(destinationUrl);
  }
  function shallowPush(path) {
    const destinationUrl = makeDestinationUrlWithPreservedQueryParameters(path);
    return router.shallowPush(destinationUrl);
  }
  return {
    child,
    match,
    mode: router.mode,
    name: router.name,
    push,
    replace,
    shallowPush,
    pathname: router.pathname,
    searchParams: router.searchParams,
    basePath: normalizedBasePath
  };
}

// src/react/router/react.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var ClerkRouterContext = (0, import_react2.createContext)(null);
function useClerkRouter() {
  const ctx = (0, import_react2.useContext)(ClerkRouterContext);
  if (!ctx) {
    throw new Error("clerk: Unable to locate ClerkRouter, make sure this is rendered within `<Router>`.");
  }
  return ctx;
}
function Router({
  basePath,
  children,
  router
}) {
  const clerkRouter = createClerkRouter(router, basePath);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ClerkRouterContext.Provider, { value: clerkRouter, children });
}

// src/react/router/virtual.ts
var import_react3 = require("react");
var DUMMY_ORIGIN = "https://clerk.dummy";
var _url, _listeners;
var VirtualRouter = class {
  constructor(path) {
    this.name = "VirtualRouter";
    this.mode = "virtual";
    __privateAdd(this, _url);
    __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
    const origin = typeof window === "undefined" ? DUMMY_ORIGIN : window.location.origin;
    __privateSet(this, _url, new URL(path != null ? path : "/", origin));
  }
  push(path) {
    const newUrl = new URL(__privateGet(this, _url).toString());
    newUrl.pathname = path;
    __privateSet(this, _url, newUrl);
    this.emit();
  }
  replace(path) {
    this.push(path);
  }
  shallowPush(path) {
    this.push(path);
  }
  pathname() {
    return __privateGet(this, _url).pathname;
  }
  searchParams() {
    return __privateGet(this, _url).searchParams;
  }
  subscribe(listener) {
    __privateGet(this, _listeners).add(listener);
    return () => __privateGet(this, _listeners).delete(listener);
  }
  emit() {
    __privateGet(this, _listeners).forEach((listener) => listener(__privateGet(this, _url)));
  }
  getSnapshot() {
    return __privateGet(this, _url);
  }
};
_url = new WeakMap();
_listeners = new WeakMap();
var virtualRouter = new VirtualRouter("/");
var useVirtualRouter = () => {
  const url = (0, import_react3.useSyncExternalStore)(
    virtualRouter.subscribe.bind(virtualRouter),
    virtualRouter.getSnapshot.bind(virtualRouter)
  );
  return {
    mode: virtualRouter.mode,
    name: virtualRouter.name,
    pathname: () => url.pathname,
    push: virtualRouter.push.bind(virtualRouter),
    replace: virtualRouter.replace.bind(virtualRouter),
    searchParams: () => url.searchParams,
    shallowPush: virtualRouter.shallowPush.bind(virtualRouter)
  };
};

// src/react/utils/create-context-from-actor-ref.ts
var import_react5 = require("@xstate/react");
var React = __toESM(require("react"));
function createContextFromActorRef(displayName) {
  const ReactContext = React.createContext(null);
  const OriginalProvider = ReactContext.Provider;
  function Provider({ children, actorRef }) {
    return React.createElement(
      OriginalProvider,
      {
        value: actorRef
      },
      children
    );
  }
  Provider.displayName = displayName;
  function useContext4(allowMissingActor = false) {
    const actorRef = React.useContext(ReactContext);
    if (!allowMissingActor && !actorRef) {
      throw new Error(
        `You used a hook from "${Provider.displayName}" but it's not inside a <${Provider.displayName}.Provider> component.`
      );
    }
    return actorRef;
  }
  function useSelector4(selector, compare) {
    const actor2 = useContext4();
    return (0, import_react5.useSelector)(actor2, selector, compare);
  }
  return {
    Provider,
    useActorRef: useContext4,
    useSelector: useSelector4
  };
}

// src/react/sign-up/context/router.context.ts
var SignUpRouterCtx = createContextFromActorRef("SignUpRouterCtx");
function useSignUpStep(name) {
  return SignUpRouterCtx.useSelector((state) => state.children[name]);
}
var useSignUpStartStep = () => useSignUpStep("start");
var useSignUpContinueStep = () => useSignUpStep("continue");
var useSignUpVerificationStep = () => useSignUpStep("verification");

// src/react/common/form/index.tsx
var import_clerk_react2 = require("@clerk/clerk-react");
var import_logger = require("@clerk/shared/logger");
var import_telemetry = require("@clerk/shared/telemetry");

// ../../node_modules/@radix-ui/primitive/dist/index.mjs
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}

// src/react/common/form/index.tsx
var import_react_form2 = require("@radix-ui/react-form");
var import_react_slot = require("@radix-ui/react-slot");
var React5 = __toESM(require("react"));

// src/react/hooks/use-password.hook.ts
var import_clerk_react = require("@clerk/clerk-react");
var import_shared5 = require("@clerk/shared");
var React2 = __toESM(require("react"));

// src/react/utils/generate-password-error-text.ts
var errorMessages = {
  max_length: ["less than %length% characters", "length"],
  min_length: ["%length% or more characters", "length"],
  require_numbers: "a number",
  require_lowercase: "a lowercase letter",
  require_uppercase: "an uppercase letter",
  require_special_char: "a special character"
};
var createListFormat = (message) => {
  let messageWithPrefix;
  if ("ListFormat" in Intl) {
    const formatter = new Intl.ListFormat("en", { style: "long", type: "conjunction" });
    messageWithPrefix = formatter.format(message);
  } else {
    messageWithPrefix = message.join(", ");
  }
  return messageWithPrefix;
};
var generatePasswordErrorText = ({ config, failedValidations }) => {
  const keys = [];
  if (!failedValidations || Object.keys(failedValidations).length === 0) {
    return {
      keys,
      message: ""
    };
  }
  const hasMinLengthError = (failedValidations == null ? void 0 : failedValidations.min_length) || false;
  const messages = Object.entries(failedValidations).filter((k) => hasMinLengthError ? k[0] === "min_length" : true).filter(([, v]) => !!v).map(([k]) => {
    const entry = k;
    keys.push(entry);
    const errorKey = errorMessages[entry];
    if (Array.isArray(errorKey)) {
      const [msg, replaceValue] = errorKey;
      return msg.replace(`%${replaceValue}%`, config[k]);
    }
    return errorKey;
  });
  const messageWithPrefix = createListFormat(messages);
  return {
    keys,
    message: `Your password must contain ${messageWithPrefix}.`
  };
};

// src/react/hooks/use-password.hook.ts
var usePassword = (callbacks) => {
  var _a3;
  const clerk = (0, import_clerk_react.useClerk)();
  const passwordSettings = (_a3 = clerk.__unstable__environment) == null ? void 0 : _a3.userSettings.passwordSettings;
  const { disable_hibp, min_zxcvbn_strength, show_zxcvbn, ...config } = passwordSettings || {};
  const {
    onValidationError = import_shared5.noop,
    onValidationSuccess = import_shared5.noop,
    onValidationWarning = import_shared5.noop,
    onValidationInfo = import_shared5.noop,
    onValidationComplexity
  } = callbacks || {};
  const onValidate = React2.useCallback(
    (res) => {
      var _a4, _b3, _c;
      if (res.complexity) {
        if (Object.values(res == null ? void 0 : res.complexity).length > 0) {
          const { message, keys } = generatePasswordErrorText({
            config,
            failedValidations: res.complexity
          });
          if ((_a4 = res.complexity) == null ? void 0 : _a4.min_length) {
            return onValidationInfo(message, keys);
          }
          return onValidationError(message, keys);
        }
      }
      if (((_b3 = res == null ? void 0 : res.strength) == null ? void 0 : _b3.state) === "fail") {
        const keys = res.strength.keys;
        const error = keys.map((key) => get(zxcvbnKeys, key)).join(" ");
        return onValidationError(error, keys);
      }
      if (((_c = res == null ? void 0 : res.strength) == null ? void 0 : _c.state) === "pass") {
        const keys = res.strength.keys;
        const error = keys.map((key) => get(zxcvbnKeys, key)).join(" ");
        return onValidationWarning(error, keys);
      }
      return onValidationSuccess();
    },
    [callbacks]
  );
  const validatePassword = React2.useMemo(() => {
    return (password) => {
      return clerk.client.signUp.validatePassword(password, {
        onValidation: onValidate,
        onValidationComplexity
      });
    };
  }, [onValidate]);
  return {
    validatePassword
  };
};
var get = (t, path) => path.split(".").reduce((r, k) => r == null ? void 0 : r[k], t);
var zxcvbnKeys = {
  unstable__errors: {
    zxcvbn: {
      couldBeStronger: "Your password works, but could be stronger. Try adding more characters.",
      goodPassword: "Your password meets all the necessary requirements.",
      notEnough: "Your password is not strong enough.",
      suggestions: {
        allUppercase: "Capitalize some, but not all letters.",
        anotherWord: "Add more words that are less common.",
        associatedYears: "Avoid years that are associated with you.",
        capitalization: "Capitalize more than the first letter.",
        dates: "Avoid dates and years that are associated with you.",
        l33t: "Avoid predictable letter substitutions like '@' for 'a'.",
        longerKeyboardPattern: "Use longer keyboard patterns and change typing direction multiple times.",
        noNeed: "You can create strong passwords without using symbols, numbers, or uppercase letters.",
        pwned: "If you use this password elsewhere, you should change it.",
        recentYears: "Avoid recent years.",
        repeated: "Avoid repeated words and characters.",
        reverseWords: "Avoid reversed spellings of common words.",
        sequences: "Avoid common character sequences.",
        useWords: "Use multiple words, but avoid common phrases."
      },
      warnings: {
        common: "This is a commonly used password.",
        commonNames: "Common names and surnames are easy to guess.",
        dates: "Dates are easy to guess.",
        extendedRepeat: 'Repeated character patterns like "abcabcabc" are easy to guess.',
        keyPattern: "Short keyboard patterns are easy to guess.",
        namesByThemselves: "Single names or surnames are easy to guess.",
        pwned: "Your password was exposed by a data breach on the Internet.",
        recentYears: "Recent years are easy to guess.",
        sequences: 'Common character sequences like "abc" are easy to guess.',
        similarToCommon: "This is similar to a commonly used password.",
        simpleRepeat: 'Repeated characters like "aaa" are easy to guess.',
        straightRow: "Straight rows of keys on your keyboard are easy to guess.",
        topHundred: "This is a frequently used password.",
        topTen: "This is a heavily used password.",
        userInputs: "There should not be any personal or page related data.",
        wordByItself: "Single words are easy to guess."
      }
    }
  }
};

// src/react/sign-in/context/router.context.ts
var SignInRouterCtx = createContextFromActorRef("SignInRouterCtx");
var useSignInPasskeyAutofill = () => SignInRouterCtx.useSelector((state) => state.context.webAuthnAutofillSupport);

// src/react/utils/is-react-fragment.ts
var React3 = __toESM(require("react"));
function isReactFragment(node) {
  return React3.isValidElement(node) && node.type === React3.Fragment;
}

// src/react/common/form/otp.tsx
var import_react_form = require("@radix-ui/react-form");
var React4 = __toESM(require("react"));
var import_jsx_runtime2 = require("react/jsx-runtime");
var ZERO = [0, 0];
var OUTSIDE = [-1, -1];
var OTP_LENGTH_DEFAULT = 6;
var PASSWORD_MANAGER_OFFSET_DEFAULT = 40;
var OTPInput = React4.forwardRef(function OTPInput2(props, ref) {
  const { render, length, autoSubmit, ...rest } = props;
  const hasRenderProp = typeof render !== "undefined";
  if (hasRenderProp) {
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      OTPInputSegmented,
      {
        ...rest,
        ref,
        render,
        length,
        autoSubmit
      }
    );
  }
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    OTPInputStandard,
    {
      ...rest,
      ref,
      length,
      autoSubmit
    }
  );
});
var OTPInputStandard = React4.forwardRef(
  function OTPInput3(props, ref) {
    const { length = OTP_LENGTH_DEFAULT, autoSubmit = false, ...rest } = props;
    const innerRef = React4.useRef(null);
    React4.useImperativeHandle(ref, () => innerRef.current, []);
    React4.useEffect(() => {
      var _a3, _b3;
      if (String(props.value).length === length && autoSubmit) {
        (_b3 = (_a3 = innerRef.current) == null ? void 0 : _a3.form) == null ? void 0 : _b3.requestSubmit();
      }
    }, [props.value, length, autoSubmit]);
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      import_react_form.Control,
      {
        ref: innerRef,
        ...rest,
        "data-otp-input-standard": true
      }
    );
  }
);
var OTPInputSegmented = React4.forwardRef(
  function OTPInput4(props, ref) {
    const {
      className: userProvidedClassName,
      render,
      length = OTP_LENGTH_DEFAULT,
      autoSubmit = false,
      passwordManagerOffset = PASSWORD_MANAGER_OFFSET_DEFAULT,
      ...rest
    } = props;
    const innerRef = React4.useRef(null);
    const [selectionRange, setSelectionRange] = React4.useState(props.autoFocus ? ZERO : OUTSIDE);
    const [isHovering, setIsHovering] = React4.useState(false);
    const isFocused = () => document.activeElement === innerRef.current;
    React4.useImperativeHandle(ref, () => innerRef.current, []);
    React4.useLayoutEffect(() => {
      if (document.activeElement !== innerRef.current) {
        return;
      }
      setSelectionRange((cur) => selectionRangeUpdater(cur, innerRef));
    }, [props.value]);
    React4.useEffect(() => {
      function onSelectionChange() {
        if (!isFocused()) {
          return;
        }
        setSelectionRange((cur) => selectionRangeUpdater(cur, innerRef));
      }
      document.addEventListener("selectionchange", onSelectionChange, { capture: true });
      return () => document.removeEventListener("selectionchange", onSelectionChange);
    }, []);
    React4.useEffect(() => {
      var _a3, _b3;
      if (String(props.value).length === length && autoSubmit) {
        (_b3 = (_a3 = innerRef.current) == null ? void 0 : _a3.form) == null ? void 0 : _b3.requestSubmit();
      }
    }, [props.value, length, autoSubmit]);
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
      "div",
      {
        "data-otp-input-wrapper": true,
        style: wrapperStyle,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("style", { children: `
      input[data-otp-input-segmented]::selection {
        color: transparent;
        background-color: transparent;
      }
      ` }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            import_react_form.Control,
            {
              "data-otp-input-segmented": true,
              ref: innerRef,
              ...rest,
              onFocus: (event) => {
                var _a3;
                if (innerRef.current) {
                  const start = Math.min(innerRef.current.value.length, length - 1);
                  const end = innerRef.current.value.length;
                  innerRef.current.setSelectionRange(start, end);
                  setSelectionRange([start, end]);
                }
                (_a3 = rest == null ? void 0 : rest.onFocus) == null ? void 0 : _a3.call(rest, event);
              },
              onBlur: (event) => {
                var _a3;
                setSelectionRange([-1, -1]);
                (_a3 = rest == null ? void 0 : rest.onBlur) == null ? void 0 : _a3.call(rest, event);
              },
              onMouseOver: (event) => {
                var _a3;
                if (!isFocused()) {
                  setIsHovering(true);
                }
                (_a3 = props.onMouseOver) == null ? void 0 : _a3.call(props, event);
              },
              onMouseLeave: (event) => {
                var _a3;
                setIsHovering(false);
                (_a3 = props.onMouseLeave) == null ? void 0 : _a3.call(props, event);
              },
              style: {
                ...inputStyle,
                clipPath: `inset(0 calc(1ch + ${passwordManagerOffset}px) 0 0)`,
                width: `calc(100% + 1ch + ${passwordManagerOffset}px)`
              }
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "div",
            {
              className: userProvidedClassName,
              "aria-hidden": true,
              style: segmentWrapperStyle,
              children: Array.from({ length }).map((_, i) => {
                var _a3, _b3;
                const isHovered = isHovering && !isFocused();
                const isCursor = selectionRange[0] === selectionRange[1] && selectionRange[0] === i;
                const isSelected = ((_a3 = selectionRange[0]) != null ? _a3 : -1) <= i && ((_b3 = selectionRange[1]) != null ? _b3 : -1) > i;
                return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(React4.Fragment, { children: render({
                  value: String(props.value)[i] || "",
                  status: isHovered ? "hovered" : isCursor ? "cursor" : isSelected ? "selected" : "none",
                  index: i
                }) }, `otp-segment-${i}`);
              })
            }
          )
        ]
      }
    );
  }
);
function selectionRangeUpdater(cur, inputRef) {
  var _a3, _b3, _c, _d, _e, _f, _g, _h, _i;
  let updated = [
    (_b3 = (_a3 = inputRef.current) == null ? void 0 : _a3.selectionStart) != null ? _b3 : 0,
    (_d = (_c = inputRef.current) == null ? void 0 : _c.selectionEnd) != null ? _d : 0,
    (_f = (_e = inputRef.current) == null ? void 0 : _e.selectionDirection) != null ? _f : null
  ];
  if (cur[0] === updated[0] && cur[1] === updated[1]) {
    return cur;
  }
  if (updated[0] === 0 && updated[1] === 1) {
    updated[2] = "forward";
  }
  if (updated[0] === updated[1]) {
    if (updated[0] > 0 && cur[0] === updated[0] && cur[1] === updated[0] + 1) {
      updated = [updated[0] - 1, updated[1], "backward"];
    } else if (typeof ((_g = inputRef.current) == null ? void 0 : _g.value[updated[0]]) !== "undefined") {
      updated = [updated[0], updated[1] + 1, "backward"];
    } else if (updated[0] >= OTP_LENGTH_DEFAULT) {
      updated = [updated[0] - 1, updated[1], "backward"];
    }
  }
  (_i = inputRef.current) == null ? void 0 : _i.setSelectionRange(updated[0], updated[1], (_h = updated[2]) != null ? _h : void 0);
  return [updated[0], updated[1]];
}
var wrapperStyle = {
  position: "relative",
  userSelect: "none"
};
var inputStyle = {
  display: "block",
  background: "transparent",
  opacity: 1,
  outline: "transparent solid 0px",
  appearance: "none",
  color: "transparent",
  position: "absolute",
  inset: 0,
  caretColor: "transparent",
  border: "0 px solid transparent",
  // width is handled inline
  height: "100%",
  letterSpacing: "-1rem"
};
var segmentWrapperStyle = {
  zIndex: 1,
  pointerEvents: "none"
};

// src/react/common/form/types.ts
var FIELD_STATES = {
  success: "success",
  error: "error",
  idle: "idle",
  warning: "warning",
  info: "info"
};
var FIELD_VALIDITY = {
  valid: "valid",
  invalid: "invalid"
};

// src/react/common/form/index.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
var FieldContext = React5.createContext(null);
var useFieldContext = () => React5.useContext(FieldContext);
var useGlobalErrors = () => {
  const errors = useFormSelector(globalErrorsSelector);
  return {
    errors
  };
};
var useFieldFeedback = ({ name }) => {
  const feedback = useFormSelector(fieldFeedbackSelector(name));
  return {
    feedback
  };
};
var determineInputTypeFromName = (name) => {
  if (name === "password" || name === "confirmPassword" || name === "currentPassword" || name === "newPassword") {
    return "password";
  }
  if (name === "emailAddress") {
    return "email";
  }
  if (name === "phoneNumber") {
    return "tel";
  }
  if (name === "code") {
    return "otp";
  }
  return "text";
};
var useFieldState = ({ name }) => {
  const { feedback } = useFieldFeedback({ name });
  const hasValue = useFormSelector(fieldHasValueSelector(name));
  let state = FIELD_STATES.idle;
  if (!hasValue) {
    state = FIELD_STATES.idle;
  }
  switch (feedback == null ? void 0 : feedback.type) {
    case "error":
      state = FIELD_STATES.error;
      break;
    case "warning":
      state = FIELD_STATES.warning;
      break;
    case "info":
      state = FIELD_STATES.info;
      break;
    case "success":
      state = FIELD_STATES.success;
      break;
    default:
      break;
  }
  return {
    state
  };
};
var useForm = ({ flowActor }) => {
  const { errors } = useGlobalErrors();
  const validity = errors.length > 0 ? FIELD_VALIDITY.invalid : FIELD_VALIDITY.valid;
  const onSubmit = React5.useCallback(
    (event) => {
      event.preventDefault();
      if (flowActor) {
        flowActor.send({ type: "SUBMIT" });
      }
    },
    [flowActor]
  );
  return {
    props: {
      [`data-${validity}`]: true,
      onSubmit
    }
  };
};
var useField = ({ name }) => {
  const hasValue = useFormSelector(fieldHasValueSelector(name));
  const { feedback } = useFieldFeedback({ name });
  const shouldBeHidden = false;
  const hasError = feedback ? feedback.type === "error" : false;
  const validity = hasError ? FIELD_VALIDITY.invalid : FIELD_VALIDITY.valid;
  return {
    hasValue,
    props: {
      [`data-${validity}`]: true,
      "data-hidden": shouldBeHidden ? true : void 0,
      serverInvalid: hasError
    }
  };
};
var useInput = ({
  name: inputName,
  value: initialValue,
  type: inputType,
  onChange: onChangeProp,
  onBlur: onBlurProp,
  onFocus: onFocusProp,
  ...passthroughProps
}) => {
  const fieldContext = useFieldContext();
  const name = inputName || (fieldContext == null ? void 0 : fieldContext.name);
  const { state: fieldState } = useFieldState({ name });
  if (!name) {
    throw new Error("Clerk: <Input /> must be wrapped in a <Field> component or have a name prop.");
  }
  const ref = useFormStore();
  const [hasPassedValiation, setHasPassedValidation] = React5.useState(false);
  const { validatePassword } = usePassword({
    onValidationComplexity: (hasPassed) => setHasPassedValidation(hasPassed),
    onValidationSuccess: () => {
      ref.send({
        type: "FIELD.FEEDBACK.SET",
        field: { name, feedback: { type: "success", message: "Your password meets all the necessary requirements." } }
      });
    },
    onValidationError: (error, keys) => {
      if (error) {
        ref.send({
          type: "FIELD.FEEDBACK.SET",
          field: {
            name,
            feedback: {
              type: "error",
              message: new ClerkElementsFieldError("password-validation-error", error),
              codes: keys
            }
          }
        });
      }
    },
    onValidationWarning: (warning, keys) => ref.send({
      type: "FIELD.FEEDBACK.SET",
      field: { name, feedback: { type: "warning", message: warning, codes: keys } }
    }),
    onValidationInfo: (info, keys) => {
      ref.send({
        type: "FIELD.FEEDBACK.SET",
        field: { name, feedback: { type: "info", message: info, codes: keys } }
      });
    }
  });
  const value = useFormSelector(fieldValueSelector(name));
  const hasValue = Boolean(value);
  const type = inputType != null ? inputType : determineInputTypeFromName(name);
  let shouldValidatePassword = false;
  if (type === "password" || type === "text") {
    shouldValidatePassword = Boolean(passthroughProps.validatePassword);
  }
  React5.useEffect(() => {
    if (!name || ref.getSnapshot().context.fields.get(name)) {
      return;
    }
    ref.send({ type: "FIELD.ADD", field: { name, value: initialValue } });
    return () => ref.send({ type: "FIELD.REMOVE", field: { name } });
  }, [ref]);
  const onChange = React5.useCallback(
    (event) => {
      onChangeProp == null ? void 0 : onChangeProp(event);
      if (!name || initialValue) {
        return;
      }
      ref.send({ type: "FIELD.UPDATE", field: { name, value: event.target.value } });
      if (shouldValidatePassword) {
        validatePassword(event.target.value);
      }
    },
    [ref, name, onChangeProp, initialValue, shouldValidatePassword, validatePassword]
  );
  const onBlur = React5.useCallback(
    (event) => {
      onBlurProp == null ? void 0 : onBlurProp(event);
      if (shouldValidatePassword) {
        validatePassword(event.target.value);
      }
    },
    [onBlurProp, shouldValidatePassword, validatePassword]
  );
  const onFocus = React5.useCallback(
    (event) => {
      onFocusProp == null ? void 0 : onFocusProp(event);
      if (shouldValidatePassword) {
        validatePassword(event.target.value);
      }
    },
    [onFocusProp, shouldValidatePassword, validatePassword]
  );
  React5.useEffect(() => {
    if (!initialValue || !name) {
      return;
    }
    ref.send({ type: "FIELD.UPDATE", field: { name, value: initialValue } });
  }, [name, ref, initialValue]);
  if (!name) {
    throw new Error("Clerk: <Input /> must be wrapped in a <Field> component or have a name prop.");
  }
  const shouldBeHidden = false;
  const Element = type === "otp" ? OTPInput : import_react_form2.Control;
  let props = {};
  if (type === "otp") {
    const p = passthroughProps;
    const length = p.length || OTP_LENGTH_DEFAULT;
    props = {
      "data-otp-input": true,
      autoComplete: "one-time-code",
      inputMode: "numeric",
      pattern: `[0-9]{${length}}`,
      minLength: length,
      maxLength: length,
      onChange: (event) => {
        event.currentTarget.value = event.currentTarget.value.replace(/\D+/g, "");
        onChange(event);
      },
      type: "text",
      spellCheck: false
    };
  }
  if (type === "password" && shouldValidatePassword) {
    props = {
      "data-has-passed-validation": hasPassedValiation ? true : void 0
    };
  }
  const { validatePassword: _1, ...rest } = passthroughProps;
  return {
    Element,
    props: {
      type,
      value: value != null ? value : "",
      onChange,
      onBlur,
      onFocus,
      "data-hidden": shouldBeHidden ? true : void 0,
      "data-has-value": hasValue ? true : void 0,
      "data-state": fieldState,
      ...props,
      ...rest
    }
  };
};
var FORM_NAME = "ClerkElementsForm";
var Form = React5.forwardRef(({ flowActor, onSubmit, ...rest }, forwardedRef) => {
  const form = useForm({ flowActor });
  const { onSubmit: internalOnSubmit, ...internalFormProps } = form.props;
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    import_react_form2.Form,
    {
      ...internalFormProps,
      ...rest,
      onSubmit: $e42e1063c40fb3ef$export$b9ecd428b558ff10(internalOnSubmit, onSubmit),
      ref: forwardedRef
    }
  );
});
Form.displayName = FORM_NAME;
var FIELD_NAME = "ClerkElementsField";
var FIELD_INNER_NAME = "ClerkElementsFieldInner";
var FIELD_STATE_NAME = "ClerkElementsFieldState";
var Field = React5.forwardRef(({ alwaysShow, ...rest }, forwardedRef) => {
  var _a3;
  const formRef = useFormStore();
  const formCtx = formRef.getSnapshot().context;
  const isHiddenField = formCtx.progressive && Boolean((_a3 = formCtx.hidden) == null ? void 0 : _a3.has(rest.name));
  const shouldHide = alwaysShow ? false : isHiddenField;
  return shouldHide ? null : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(FieldContext.Provider, { value: { name: rest.name }, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    FieldInner,
    {
      ...rest,
      ref: forwardedRef
    }
  ) });
});
var FieldInner = React5.forwardRef((props, forwardedRef) => {
  const { children, ...rest } = props;
  const field = useField({ name: rest.name });
  const { state: fieldState } = useFieldState({ name: rest.name });
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    import_react_form2.Field,
    {
      ...field.props,
      ...rest,
      ref: forwardedRef,
      children: typeof children === "function" ? children(fieldState) : children
    }
  );
});
Field.displayName = FIELD_NAME;
FieldInner.displayName = FIELD_INNER_NAME;
function FieldState({ children }) {
  const field = useFieldContext();
  const { feedback } = useFieldFeedback({ name: field == null ? void 0 : field.name });
  const { state } = useFieldState({ name: field == null ? void 0 : field.name });
  const message = (feedback == null ? void 0 : feedback.message) instanceof ClerkElementsFieldError ? feedback.message.message : feedback == null ? void 0 : feedback.message;
  const codes = feedback == null ? void 0 : feedback.codes;
  const fieldState = { state, message, codes };
  return children(fieldState);
}
FieldState.displayName = FIELD_STATE_NAME;
var INPUT_NAME = "ClerkElementsInput";
var Input = React5.forwardRef(
  (props, forwardedRef) => {
    var _a3, _b3, _c;
    const clerk = (0, import_clerk_react2.useClerk)();
    const field = useInput(props);
    const hasPasskeyAutofillProp = Boolean((_a3 = field.props.autoComplete) == null ? void 0 : _a3.includes("webauthn"));
    const allowedTypeForPasskey = ["text", "email", "tel"].includes(field.props.type);
    const signInRouterRef = SignInRouterCtx.useActorRef(true);
    (_c = clerk.telemetry) == null ? void 0 : _c.record(
      (0, import_telemetry.eventComponentMounted)("Elements_Input", {
        type: (_b3 = props.type) != null ? _b3 : false,
        // @ts-expect-error - Depending on type the props can be different
        render: Boolean(props == null ? void 0 : props.render),
        // @ts-expect-error - Depending on type the props can be different
        asChild: Boolean(props == null ? void 0 : props.asChild),
        // @ts-expect-error - Depending on type the props can be different
        validatePassword: Boolean(props == null ? void 0 : props.validatePassword)
      })
    );
    if (signInRouterRef && hasPasskeyAutofillProp && allowedTypeForPasskey) {
      return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        InputWithPasskeyAutofill,
        {
          ref: forwardedRef,
          ...props
        }
      );
    }
    if (hasPasskeyAutofillProp && !allowedTypeForPasskey) {
      import_logger.logger.warnOnce(
        `<Input autoComplete="webauthn"> can only be used with <Input type="text"> or <Input type="email">`
      );
    } else if (hasPasskeyAutofillProp) {
      import_logger.logger.warnOnce(
        `<Input autoComplete="webauthn"> can only be used inside <SignIn> in order to trigger a sign-in attempt, otherwise it will be ignored.`
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      field.Element,
      {
        ref: forwardedRef,
        ...field.props
      }
    );
  }
);
Input.displayName = INPUT_NAME;
var InputWithPasskeyAutofill = React5.forwardRef(
  (props, forwardedRef) => {
    const signInRouterRef = SignInRouterCtx.useActorRef(true);
    const passkeyAutofillSupported = useSignInPasskeyAutofill();
    React5.useEffect(() => {
      if (passkeyAutofillSupported) {
        signInRouterRef == null ? void 0 : signInRouterRef.send({ type: "AUTHENTICATE.PASSKEY.AUTOFILL" });
      }
    }, [passkeyAutofillSupported, signInRouterRef]);
    const field = useInput(props);
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      field.Element,
      {
        ref: forwardedRef,
        ...field.props
      }
    );
  }
);
var LABEL_NAME = "ClerkElementsLabel";
var Label = import_react_form2.Label;
Label.displayName = LABEL_NAME;
var SUBMIT_NAME = "ClerkElementsSubmit";
var Submit = import_react_form2.Submit;
Submit.displayName = SUBMIT_NAME;
var GLOBAL_ERROR_NAME = "ClerkElementsGlobalError";
var FIELD_ERROR_NAME = "ClerkElementsFieldError";
var GlobalError = React5.forwardRef(
  ({ asChild = false, children, code, ...rest }, forwardedRef) => {
    const { errors } = useGlobalErrors();
    const error = errors == null ? void 0 : errors[0];
    if (!error || code && error.code !== code) {
      return null;
    }
    const Comp = asChild ? import_react_slot.Slot : "div";
    const child = typeof children === "function" ? children(error) : children;
    if (isReactFragment(child)) {
      throw new ClerkElementsRuntimeError("<GlobalError /> cannot render a Fragment as a child.");
    }
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      Comp,
      {
        role: "alert",
        ...rest,
        ref: forwardedRef,
        children: child || error.message
      }
    );
  }
);
var FieldError = React5.forwardRef(
  ({ asChild = false, children, code, name, ...rest }, forwardedRef) => {
    const fieldContext = useFieldContext();
    const fieldName = (fieldContext == null ? void 0 : fieldContext.name) || name;
    const { feedback } = useFieldFeedback({ name: fieldName });
    if (!((feedback == null ? void 0 : feedback.type) === "error")) {
      return null;
    }
    const error = feedback.message;
    if (!error) {
      return null;
    }
    const Comp = asChild ? import_react_slot.Slot : "span";
    const child = typeof children === "function" ? children(error) : children;
    if (isReactFragment(child)) {
      throw new ClerkElementsRuntimeError("<FieldError /> cannot render a Fragment as a child.");
    }
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      import_react_form2.FormMessage,
      {
        "data-error-code": error.code,
        ...rest,
        ref: forwardedRef,
        asChild: true,
        children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Comp, { children: child || error.message })
      }
    );
  }
);
GlobalError.displayName = GLOBAL_ERROR_NAME;
FieldError.displayName = FIELD_ERROR_NAME;

// src/react/utils/path-inference/next.tsx
var import_router6 = require("next/compat/router");
var import_navigation2 = require("next/navigation");
var import_react6 = __toESM(require("react"));

// src/react/utils/path-inference/utils.ts
function removeOptionalCatchAllSegment(pathname) {
  return pathname.replace(/\/\[\[\.\.\..*/, "");
}

// src/react/utils/path-inference/next.tsx
var usePathnameWithoutCatchAll = () => {
  const pathRef = import_react6.default.useRef();
  const pagesRouter = (0, import_router6.useRouter)();
  if (pagesRouter) {
    if (pathRef.current) {
      return pathRef.current;
    } else {
      pathRef.current = removeOptionalCatchAllSegment(pagesRouter.pathname);
      return pathRef.current;
    }
  }
  const pathname = (0, import_navigation2.usePathname)() || "";
  const pathParts = pathname.split("/").filter(Boolean);
  const catchAllParams = Object.values((0, import_navigation2.useParams)() || {}).filter((v) => Array.isArray(v)).flat(Infinity);
  if (pathRef.current) {
    return pathRef.current;
  } else {
    pathRef.current = `/${pathParts.slice(0, pathParts.length - catchAllParams.length).join("/")}`;
    return pathRef.current;
  }
};

// src/react/sign-up/root.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
var actor = (0, import_xstate8.createActor)(SignUpRouterMachine, { inspect });
actor.start();
function SignUpFlowProvider({ children, exampleMode }) {
  const clerk = (0, import_clerk_react3.useClerk)();
  const router = useClerkRouter();
  const formRef = useFormStore();
  const isReady = (0, import_react7.useSelector)(actor, (state) => state.value !== "Idle");
  (0, import_react8.useEffect)(() => {
    if (!clerk || !router) {
      return;
    }
    clerk.addOnLoaded(() => {
      const evt = {
        type: "INIT",
        clerk,
        exampleMode,
        formRef,
        router,
        signInPath: SIGN_IN_DEFAULT_BASE_PATH
      };
      if (actor.getSnapshot().can(evt)) {
        actor.send(evt);
      }
      if (formRef && actor.getSnapshot().can({ type: "RESET.STEP" })) {
        actor.send({
          type: "FORM.ATTACH",
          formRef
        });
      }
    });
  }, [clerk, exampleMode, formRef == null ? void 0 : formRef.id, !!router]);
  return isReady ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(SignUpRouterCtx.Provider, { actorRef: actor, children }) : null;
}
function SignUpRoot({
  children,
  exampleMode = false,
  fallback = null,
  path: pathProp,
  routing = ROUTING.path
}) {
  var _a3;
  const clerk = (0, import_clerk_react3.useClerk)();
  const inferredPath = usePathnameWithoutCatchAll();
  const path = pathProp || inferredPath || SIGN_UP_DEFAULT_BASE_PATH;
  (_a3 = clerk.telemetry) == null ? void 0 : _a3.record(
    (0, import_telemetry2.eventComponentMounted)("Elements_SignUpRoot", {
      exampleMode,
      fallback: Boolean(fallback),
      path,
      routing
    })
  );
  const router = (routing === ROUTING.virtual ? useVirtualRouter : useNextRouter)();
  const isRootPath = path === router.pathname();
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    Router,
    {
      basePath: path,
      router,
      children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(FormStoreProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(SignUpFlowProvider, { exampleMode, children: [
        isRootPath ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_clerk_react3.ClerkLoading, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Form, { children: fallback }) }) : null,
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_clerk_react3.ClerkLoaded, { children })
      ] }) })
    }
  );
}

// src/react/sign-up/step.tsx
var import_clerk_react4 = require("@clerk/clerk-react");
var import_telemetry3 = require("@clerk/shared/telemetry");

// src/react/hooks/use-active-tags.hook.ts
var import_react9 = require("@xstate/react");
var ActiveTagsMode = {
  any: "any",
  all: "all"
};
function useActiveTags(actor2, tags, mode = ActiveTagsMode.any) {
  const state = (0, import_react9.useSelector)(
    actor2,
    (s) => s,
    (prev, next) => prev.tags === next.tags
  );
  if (typeof tags === "string") {
    return state.hasTag(tags);
  }
  if (!Array.isArray(tags)) {
    throw new Error("Invalid tags parameter provided to useActiveTags");
  }
  switch (mode) {
    case ActiveTagsMode.any: {
      const matching = new Set(tags.filter((tag) => state.hasTag(tag)));
      return { active: matching.size > 0, activeTags: matching };
    }
    case ActiveTagsMode.all:
      return tags.length === state.tags.size ? tags.every((tag) => state.hasTag(tag)) : false;
    default:
      return false;
  }
}

// src/react/sign-up/continue.tsx
var import_jsx_runtime5 = require("react/jsx-runtime");
var SignUpContinueCtx = createContextFromActorRef("SignUpContinueCtx");
function SignUpContinue(props) {
  const routerRef = SignUpRouterCtx.useActorRef();
  const activeState = useActiveTags(routerRef, "route:continue");
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(SignUpContinueInner, { ...props }) : null;
}
function SignUpContinueInner(props) {
  const ref = useSignUpContinueStep();
  if (!ref) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(SignUpContinueCtx.Provider, { actorRef: ref, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    Form,
    {
      flowActor: ref,
      ...props
    }
  ) });
}

// src/react/sign-up/start.tsx
var import_jsx_runtime6 = require("react/jsx-runtime");
var SignUpStartCtx = createContextFromActorRef("SignUpStartCtx");
function SignUpStart(props) {
  const routerRef = SignUpRouterCtx.useActorRef();
  const activeState = useActiveTags(routerRef, "route:start");
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(SignUpStartInner, { ...props }) : null;
}
function SignUpStartInner(props) {
  const ref = useSignUpStartStep();
  if (!ref) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(SignUpStartCtx.Provider, { actorRef: ref, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    Form,
    {
      flowActor: ref,
      ...props
    }
  ) });
}

// src/react/sign-up/verifications.tsx
var import_jsx_runtime7 = require("react/jsx-runtime");
var SignUpVerificationCtx = createContextFromActorRef("SignUpVerificationCtx");
function SignUpVerifications(props) {
  const ref = SignUpRouterCtx.useActorRef();
  const activeState = useActiveTags(ref, "route:verification");
  return activeState ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SignUpVerifyInner, { ...props }) : null;
}
function SignUpVerifyInner(props) {
  const ref = useSignUpVerificationStep();
  if (!ref) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SignUpVerificationCtx.Provider, { actorRef: ref, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    Form,
    {
      flowActor: ref,
      ...props
    }
  ) });
}
function SignUpStrategy({ children, name: tag }) {
  const ref = SignUpVerificationCtx.useActorRef(true);
  if (!ref) {
    throw new Error(
      '<Strategy> used outside of <SignUp>. Did you mean to `import { Strategy } from "@clerk/elements/sign-in"` instead?'
    );
  }
  const { active } = useActiveTags(ref, [
    `verification:${tag}`,
    `verification:category:${tag}`
  ]);
  return active ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children }) : null;
}

// src/react/sign-up/step.tsx
var import_jsx_runtime8 = require("react/jsx-runtime");
var SIGN_UP_STEPS = {
  start: "start",
  continue: "continue",
  verifications: "verifications"
};
function SignUpStep(props) {
  var _a3;
  const clerk = (0, import_clerk_react4.useClerk)();
  (_a3 = clerk.telemetry) == null ? void 0 : _a3.record((0, import_telemetry3.eventComponentMounted)("Elements_SignUpStep", { name: props.name }));
  switch (props.name) {
    case SIGN_UP_STEPS.start:
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(SignUpStart, { ...props });
    case SIGN_UP_STEPS.continue:
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(SignUpContinue, { ...props });
    case SIGN_UP_STEPS.verifications:
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(SignUpVerifications, { ...props });
    default:
      throw new ClerkElementsRuntimeError(`Invalid step name. Use 'start', 'continue', or 'verifications'.`);
  }
}

// src/react/sign-up/action/action.tsx
var React9 = __toESM(require("react"));

// src/react/common/index.ts
var import_client_only = require("client-only");

// src/react/sign-up/action/navigate.tsx
var import_react_slot2 = require("@radix-ui/react-slot");
var React7 = __toESM(require("react"));
var import_jsx_runtime9 = require("react/jsx-runtime");
var SIGN_UP_NAVIGATE_NAME = "SignInNavigate";
var SignUpNavigationEventMap = {
  start: `NAVIGATE.START`,
  previous: `NAVIGATE.PREVIOUS`
};
var SignUpNavigate = React7.forwardRef(
  ({ asChild, to, ...rest }, forwardedRef) => {
    const actorRef = SignUpRouterCtx.useActorRef();
    const Comp = asChild ? import_react_slot2.Slot : "button";
    const defaultProps = asChild ? {} : { type: "button" };
    const sendEvent = React7.useCallback(() => {
      const type = SignUpNavigationEventMap[to];
      if (actorRef.getSnapshot().can({ type })) {
        actorRef.send({ type });
      } else {
        console.warn("Invalid navigation event.");
      }
    }, [actorRef, to]);
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      Comp,
      {
        ...defaultProps,
        ...rest,
        onClick: sendEvent,
        ref: forwardedRef
      }
    );
  }
);
SignUpNavigate.displayName = SIGN_UP_NAVIGATE_NAME;

// src/react/sign-up/action/resend.tsx
var import_react_slot3 = require("@radix-ui/react-slot");
var import_react10 = require("@xstate/react");
var React8 = __toESM(require("react"));
var import_jsx_runtime10 = require("react/jsx-runtime");
var SIGN_UP_RESEND_NAME = "SignUpResend";
var SignUpResend = React8.forwardRef(
  ({ asChild, fallback, ...rest }, forwardedRef) => {
    const ref = SignUpVerificationCtx.useActorRef(true);
    if (!ref) {
      throw new Error('The resend action must be used within <SignUp.Step name="verifications">.');
    }
    const fallbackProps = (0, import_react10.useSelector)(
      ref,
      (state) => ({
        resendable: state.context.resendable,
        resendableAfter: state.context.resendableAfter
      }),
      (a, b) => a.resendableAfter === b.resendableAfter && a.resendable === b.resendable
    );
    if (fallback && !fallbackProps.resendable) {
      return typeof fallback === "function" ? fallback(fallbackProps) : fallback;
    }
    const Comp = asChild ? import_react_slot3.Slot : "button";
    const defaultProps = asChild ? {} : { type: "button" };
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
      Comp,
      {
        ...defaultProps,
        ...rest,
        disabled: !fallbackProps.resendable,
        onClick: () => ref.send({ type: "RETRY" }),
        ref: forwardedRef
      }
    );
  }
);
SignUpResend.displayName = SIGN_UP_RESEND_NAME;

// src/react/sign-up/action/action.tsx
var import_jsx_runtime11 = require("react/jsx-runtime");
var SignUpAction = React9.forwardRef((props, forwardedRef) => {
  const { submit, navigate, resend, ...rest } = props;
  let Comp;
  if (submit) {
    Comp = Submit;
  } else if (navigate) {
    Comp = SignUpNavigate;
  } else if (resend) {
    Comp = SignUpResend;
  }
  return Comp ? /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
    Comp,
    {
      to: navigate,
      ...rest,
      ref: forwardedRef
    }
  ) : null;
});
SignUpAction.displayName = "SignUpAction";

// src/react/sign-up/captcha.tsx
var import_react_slot4 = require("@radix-ui/react-slot");
var React10 = __toESM(require("react"));
var import_jsx_runtime12 = require("react/jsx-runtime");
var SignUpCaptcha = React10.forwardRef(
  ({ asChild, children, ...rest }, forwardedRef) => {
    const ref = SignUpStartCtx.useActorRef(true);
    if (!ref) {
      throw new ClerkElementsRuntimeError('<Captcha> must be used within the <SignUp.Step name="start"> component.');
    }
    const Comp = asChild ? import_react_slot4.Slot : "div";
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      Comp,
      {
        id: CAPTCHA_ELEMENT_ID,
        ...rest,
        ref: forwardedRef
      }
    );
  }
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Action,
  Captcha,
  Root,
  SignUp,
  Step,
  Strategy
});
//# sourceMappingURL=index.js.map